package com.serifpersia.pianoled;

import processing.core.PApplet;

/* auto generated by Processing revision 1292 on 2023-03-30 */
import processing.core.*;
import processing.serial.*;
import javax.sound.midi.*;
import themidibus.*;
import static javax.swing.JOptionPane.*;
import java.util.*;
import java.util.regex.*;
import controlP5.*;
import java.io.ByteArrayOutputStream;
import java.io.InputStreamReader;
import javax.swing.JOptionPane;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.net.URL;
import java.net.URLConnection;
import java.io.File;
import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import javax.swing.SwingUtilities;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JProgressBar;
import org.json.JSONArray;
import org.json.JSONObject;

import javax.swing.JFileChooser;
import javax.swing.filechooser.FileFilter;
import javax.swing.JTextArea;
import javax.swing.JScrollPane;
import java.awt.Color;
import java.awt.Font;

import java.util.ArrayList;
import java.io.BufferedReader;

public class PianoLED extends PApplet {

	Sequencer sequencer;
	JFrame newWindowFrame;
	boolean midiPlay = false;
	PianoRoll pianoRoll;
	int PIANO_ROLL_HEIGHT = 960;
	int PIANO_ROLL_WIDTH = 600;

	final static int TOP_COLOR = 255;

//Map function maps pitch first last note and number of leds
	public int mapMidiNoteToLED(int midiNote, int lowestNote, int highestNote, int stripLEDNumber, int outMin) {
		int outMax = outMin + stripLEDNumber - 1; // highest LED number
		int mappedLED = (midiNote - lowestNote) * (outMax - outMin) / (highestNote - lowestNote);
		return mappedLED + outMin;
	}

	public int mapMidiNoteToLEDFixed(int midiNote, int lowestNote, int highestNote, int stripLEDNumber, int outMin) {
		int outMax = outMin + stripLEDNumber - 1; // highest LED number
		int mappedLED = (midiNote - lowestNote) * (outMax - outMin) / (highestNote - lowestNote);

		if (midiNote >= 57) {
			mappedLED -= 1;
		}

		if (midiNote >= 93) {
			mappedLED -= 1;
		}
		return mappedLED + outMin;
	}

	int counter = 0;
	int lastNoteSelected, firstNoteSelected, numberselected, notePushed, noteOnVelocity;
	int leftMinPitch = 21;
	int leftMaxPitch;
	int rightMaxPitch = 108;
	boolean useFixedMapping = false;
	boolean openNewWindow = false;
	boolean BGColor = false, VelocityOn = false, RandomOn = false, SplitOn = false, GradientOn = false,
			SplashOn = false, AnimationOn = false, LearnMidiOn = false;
	List<String> m = Arrays.asList("Default", "Splash", "Random", "Gradient", "Velocity", "Split", "Animation",
			"Piano Roll");

// Create an ArrayList to hold the names of the MIDI devices
	ArrayList<String> midilist = new ArrayList<String>();
	ArrayList<String> midioutlist = new ArrayList<String>();

	String portName;
	String midiName; // midi input device
	String midiOutName; // midi output device
	String comlist[];
	String presetText;
	String os = System.getProperty("os.name").toLowerCase();
	String VersionTag;
	String VersionFile;
	String owner = "serifpersia";
	String repo = "pianoled-arduino";
	String fileName;
	String downloadUrl;
	String saveDir = System.getProperty("user.dir") + "/";
	String destinationFolderPath = System.getProperty("user.dir") + "/";
	String appPath = System.getProperty("user.dir");

	public String getDownloadUrl(JSONObject release, String fileName) {
		JSONArray assets = release.getJSONArray("assets");
		for (int i = 0; i < assets.length(); i++) {
			JSONObject asset = assets.getJSONObject(i);
			if (asset.getString("name").equals(fileName)) {
				return asset.getString("browser_download_url");
			}
		}
		return null;
	}

	public JSONObject getLatestRelease(String url) {
		try {
			// String authToken = ""; // replace with your PAT
			URL apiLink = new URL(url);
			URLConnection conn = apiLink.openConnection();
			conn.setRequestProperty("Accept", "application/vnd.github.v3+json");
			conn.setRequestProperty("User-Agent", "Java");
			// conn.setRequestProperty("Authorisation", "token " + authToken); // set the
			// authorisation header with your PAT
			BufferedInputStream in = new BufferedInputStream(conn.getInputStream());
			byte[] dataBuffer = new byte[1024];
			int bytesRead;
			StringBuilder responseBuilder = new StringBuilder();
			while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {
				responseBuilder.append(new String(dataBuffer, 0, bytesRead));
			}
			in.close();
			return new JSONObject(responseBuilder.toString());
		} catch (Exception e) {
			System.err.println("Error: " + e.getMessage());
			return null;
		}
	}

	File folder = new File(appPath);
	File[] listOfFiles = folder.listFiles();
	File versionFile = null;

	Serial arduino;
	MidiBus myBusIn;
	MidiBus myBusOut;

	public void setup() {
		/* size commented out by preprocessor */;
		surface.setTitle("PianoLED");
		PImage icon = loadImage("images/PianoLED.png"); // replace with the name and extension of your icon file
		surface.setIcon(icon);
		cp5 = buildUI();

		cp5.getController("modelist").setValue(0);

		Refresh();

		numberselected = 176;
		firstNoteSelected = 21;
		lastNoteSelected = 108;

		setSystemFileDownload();

		checkLocalVersion();
	}

	public void setSystemFileDownload() {
	}

	public void checkLocalVersion() {

		for (int i = 0; i < listOfFiles.length; i++) {
			if (listOfFiles[i].isFile()) {
				String fileName = listOfFiles[i].getName();
				if (fileName.matches(".*v\\d+\\.\\d+.*")) {
					VersionTag = fileName.replaceAll(".*(v\\d+\\.\\d+).*", "$1");
					versionFile = listOfFiles[i];
					break;
				}
			}
		}
		System.out.println("VersionTag: " + VersionTag);
	}

//button update
	public void checkForUpdates() {
		// Show confirmation dialog to check for updates
		int confirm = JOptionPane.showOptionDialog(null, "Do you want to check for updates?", "Update Checker",
				JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, null, null);

		if (confirm == JOptionPane.YES_OPTION) {
			String releaseUrl = String.format("https://api.github.com/repos/%s/%s/releases/latest", owner, repo);
			JSONObject latestRelease = getLatestRelease(releaseUrl);

			if (latestRelease == null) {
				JOptionPane.showMessageDialog(null, "Unable to retrieve latest release information.", "Update",
						JOptionPane.INFORMATION_MESSAGE);
				return;
			}

			// Compare the latest release tag with the local version tag
			if (VersionTag != null && VersionTag.equals(latestRelease.getString("tag_name"))) {
				JOptionPane.showMessageDialog(null, "You already have the latest version.", "Update",
						JOptionPane.INFORMATION_MESSAGE);
				return;
			}

			if (VersionTag == null) {
				String message = "Unable to retrieve local app information";
				JOptionPane.showMessageDialog(null, message, "Update", JOptionPane.INFORMATION_MESSAGE);
				return;
			}

			// Show confirmation dialog to download the latest release
			confirm = JOptionPane.showOptionDialog(null, "A new update is available. Do you want to download it?",
					"Update Checker", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, null, null);

			if (confirm == JOptionPane.YES_OPTION) {
				// Download and extract the latest release
				String downloadUrl, fileName;
				if (os.contains("win")) {
					fileName = "PianoLED-windows-amd64.zip";
					println("File to download: " + fileName);
				} else {
					fileName = "PianoLED-linux-amd64.zip";
				}
				downloadUrl = getDownloadUrl(latestRelease, fileName);

				try {
					// Download the file with a progress bar
					URL url = new URL(downloadUrl);
					URLConnection conn = url.openConnection();
					conn.connect();
					int contentLength = conn.getContentLength();
					BufferedInputStream in = new BufferedInputStream(conn.getInputStream());
					FileOutputStream out = new FileOutputStream(saveDir + fileName);
					BufferedOutputStream bout = new BufferedOutputStream(out, 1024);
					byte[] data = new byte[1024];
					int x = 0;
					int bytesRead = 0;

					// Create progress bar
					JProgressBar progressBar = new JProgressBar();
					progressBar.setStringPainted(true);

					// Create dialog to show progress bar
					JDialog dialog = new JDialog();
					dialog.add(progressBar);
					dialog.setTitle("Downloading update...");
					dialog.setSize(300, 75);
					dialog.setLocationRelativeTo(null);
					dialog.setVisible(true);

					while ((bytesRead = in.read(data, 0, 1024)) >= 0) {
						bout.write(data, 0, bytesRead);
						x += bytesRead;
						int percentCompleted = (int) ((x / (float) contentLength) * 100);

						// Update progress bar
						SwingUtilities.invokeLater(new Runnable() {
							public void run() {
								progressBar.setValue(percentCompleted);
							}
						});
					}
					bout.close();
					in.close();
					extractZipFile(saveDir + fileName, destinationFolderPath);
					dialog.dispose(); // Close progress bar dialog
					String restartMessage = "The app has been updated to " + latestRelease.getString("tag_name")
							+ ". Please restart PianoLED.";
					JOptionPane.showMessageDialog(null, restartMessage, "Update", JOptionPane.INFORMATION_MESSAGE);
					deleteOldFile();
				} catch (Exception e) {
				}
			}
		}
	}

	public void deleteOldFile() {
		if (versionFile != null) { // check the flag value before deleting the version file
			boolean deleted = versionFile.delete();
			if (deleted) {
				System.out.println("Deleted version file: " + versionFile.getName());
				exit();
			} else {
				System.out.println("Failed to delete version file: " + versionFile.getName());
			}
		}
	}

	public void extractZipFile(String zipFilePath, String destinationFolderPath) {
		try {
			ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(zipFilePath));
			ZipEntry zipEntry = zipInputStream.getNextEntry();
			byte[] buffer = new byte[1024];

			while (zipEntry != null) {
				String fileName = zipEntry.getName();
				File newFile = new File(destinationFolderPath + fileName);
				System.out.println("Extracting file: " + newFile.getAbsolutePath());

				if (zipEntry.isDirectory()) {
					// Create the directory
					newFile.mkdirs();
				} else {
					// Create all non-existing parent directories
					new File(newFile.getParent()).mkdirs();

					// Write the file contents
					FileOutputStream fos = new FileOutputStream(newFile);
					int len;
					while ((len = zipInputStream.read(buffer)) > 0) {
						fos.write(buffer, 0, len);
					}
					fos.close();
				}

				zipEntry = zipInputStream.getNextEntry();
			}

			zipInputStream.closeEntry();
			zipInputStream.close();

			System.out.println("Zip file extracted to: " + destinationFolderPath);

			// Delete the zip file
			File zipFile = new File(zipFilePath);
			if (zipFile.delete()) {
				System.out.println("Zip file deleted successfully");
			} else {
				System.err.println("Failed to delete zip file");
			}
		} catch (IOException e) {
			System.err.println("Error extracting zip file: " + e.getMessage());
		}
	}

	public void midi(int n) {
		try {
			// Set the midiName variable to the name of the selected MIDI device
			midiName = midilist.get(n);
			println("Selected midi input device: " + midiName);
		} catch (Exception NoDevicesAvailable) {
			println("No devices Available. plugin devices into your computer first!");
		}
	}

	public void midiout(int n) {
		try {
			// Set the midiName variable to the name of the selected MIDI device
			midiOutName = midioutlist.get(n);
			println("Selected midi output device: " + midiOutName);
		} catch (Exception NoDevicesAvailable) {
			println("No devices Available. plugin devices into your computer first!");
		}
	}

	public void noteOn(int channel, int pitch, int velocity) {

		if (useFixedMapping) {
			notePushed = mapMidiNoteToLEDFixed(pitch, firstNoteSelected, lastNoteSelected, numberselected, 1);
		} else {
			notePushed = mapMidiNoteToLED(pitch, firstNoteSelected, lastNoteSelected, numberselected, 1);
		}
		Keys[pitch - 21][0] = 1;
		Keys[pitch - 21][1] = 1;
		try {
			ByteArrayOutputStream message = null;

			if (!AnimationOn) {
				if (RandomOn) {
					message = commandSetColor((int) random(1, 250), (int) random(1, 250), (int) random(1, 250),
							notePushed);
				} else if (VelocityOn) {
					message = commandVelocity(velocity, notePushed, Red, Green, Blue);
				} else if (SplitOn) {
					if (pitch >= leftMinPitch && pitch <= leftMaxPitch - 1) {
						println("Left Side Color");
						message = commandSetColor(splitLeftRed, splitLeftGreen, splitLeftBlue, notePushed);
					} else if (pitch > leftMaxPitch - 1 && pitch <= rightMaxPitch) {
						println("Right Side Color");
						message = commandSetColor(splitRightRed, splitRightGreen, splitRightBlue, notePushed);
					}
				} else if (GradientOn) {
					int numSteps = numberselected - 1;
					int step = notePushed - 1;
					float ratio = (float) step / (float) numSteps;

					int startColor = color(LeftSideGRed, LeftSideGGreen, LeftSideGBlue);
					int endColor = color(RightSideGRed, RightSideGGreen, RightSideGBlue);

					int currentColor;
					if (MiddleSideGRed == 0 && MiddleSideGGreen == 0 && MiddleSideGBlue == 0) {
						currentColor = lerpColor(startColor, endColor, ratio);
					} else {
						int middleColor = color(MiddleSideGRed, MiddleSideGGreen, MiddleSideGBlue);
						float leftRatio = ratio * 0.5f;
						float rightRatio = (ratio - 0.5f) * 2f;

						int leftColor = lerpColor(startColor, middleColor, leftRatio);
						int rightColor = lerpColor(middleColor, endColor, rightRatio);

						currentColor = lerpColor(leftColor, rightColor, ratio);
					}

					int red = (int) red(currentColor);
					int green = (int) green(currentColor);
					int blue = (int) blue(currentColor);

					message = commandSetColor(red, green, blue, notePushed);
				} else if (SplashOn) {
					message = commandSplash(velocity, notePushed, getSplashColor());
				} else {
					message = commandSetColor(Red, Green, Blue, notePushed);
				}

				if (message != null) {
					sendToArduino(message);
				}
			}
		} catch (Exception e) {
			showMessageDialog(null, "Error sending command: " + e);
			println(e);
		}
	}

	public static void printMessage(ByteArrayOutputStream msg) {
		byte[] bytes = msg.toByteArray();
		print("Message:");
		for (byte b : bytes) {
			int unsignedValue = b & 0xFF;
			print(unsignedValue + " ");
		}
		println();
	}

	public void noteOff(int channel, int pitch, int velocity) {
		if (useFixedMapping) {
			notePushed = mapMidiNoteToLEDFixed(pitch, firstNoteSelected, lastNoteSelected, numberselected, 1);
		} else {
			notePushed = mapMidiNoteToLED(pitch, firstNoteSelected, lastNoteSelected, numberselected, 1);
		}
		Keys[pitch - 21][0] = 0;
		Keys[pitch - 21][1] = 0;
		try {
			if (!AnimationOn) {
				sendCommandKeyOff(notePushed);
			}
		} catch (Exception e) {
		}
	}

	public void comlist(int n) {
		portName = Serial.list()[n];
		println("Selected serial device: " + portName);
	}

	public void disableAllModes() {
		RandomOn = false;
		VelocityOn = false;
		AnimationOn = false;
		SplitOn = false;
		GradientOn = false;
		SplashOn = false;
	}

	public void colorlist(int n) {
		if (cp5 != null) {
			int selectedColor = presetColors[n];

			Red = round(red(selectedColor));
			Green = round(green(selectedColor));
			Blue = round(blue(selectedColor));

			cp5.get(ColorWheel.class, "Color").setRGB(selectedColor);

			println("Selected color: " + colorNames.get(n));
			println("RGB values: " + red(selectedColor) + ", " + green(selectedColor) + ", " + blue(selectedColor));
		} else {
			println("cp5 object is null");
		}
	}

	public void animationlist(int n) {
		String selectedAnimation = animationNames.get(n);
		println("Selected Animation: " + selectedAnimation);

		// Select animation based on index
		switch (n) {
		case 0:
			// Select Animation 1
			sendCommandAnimation(0);
			break;
		case 1:
			// Select Animation 2
			sendCommandAnimation(1);
			break;
		case 2:
			// Select Animation 3
			sendCommandAnimation(2);
			break;
		case 3:
			// Select Animation 4
			sendCommandAnimation(3);
			break;
		case 4:
			// Select Animation 5
			sendCommandAnimation(4);
			break;
		case 5:
			// Select Animation 6
			sendCommandAnimation(5);
			break;
		case 6:
			// Select Animation 7
			sendCommandAnimation(6);
			break;
		default:
			println("Invalid animation selection.");
			break;
		}
	}

	public void BGColor(boolean on) {
		println("Set BG: " + on);
		int BG_HUE = 100;
		int BG_SATURATION = 0;
		int BG_BRIGHTNESS = 20;

		if (on) {
			sendCommandSetBG(BG_HUE, BG_SATURATION, BG_BRIGHTNESS);
			showBGControls();
		} else {
			sendCommandSetBG(0, 0, 0);
			hideBGControls();
		}
	}

	public void stripDirection(boolean on) {
		sendCommandStripDirection(on ? 1 : 0, numberselected);
	}

	public void TeacherFollowKey(boolean on) {
		pianoRoll.setFollowKey(on);
	}

	public void Fix() {
		useFixedMapping = !useFixedMapping; // toggle the state
	}

	public void setBG() {
		int red = Red; // Red value from 0-255
		int green = Green; // Green value from 0-255
		int blue = Blue; // Blue value from 0-255

		float[] hsbValues = java.awt.Color.RGBtoHSB(red, green, blue, null);
		int hue = (int) (hsbValues[0] * 255);
		int saturation = (int) (hsbValues[1] * 255);
		int brightness = 20;

		sendCommandSetBG(hue, saturation, brightness);
	}

	public void modelist(int n) {
		if (cp5 != null) {
			sendCommandBlackOut();

			switch (n) {
			case 0: // Default
				disableAllModes();
				hideAllControls();
				showDefaultControls();
				setDefaultDefaults(255, 127);
				break;
			case 1: // Splash
				disableAllModes();
				hideAllControls();
				showSplashControls();
				setSplashDefaults(11, 110, 0, 127);
				SplashOn = true;
				break;
			case 2: // Random
				disableAllModes();
				hideAllControls();
				setDefaultDefaults(255, 127);
				showRandomControls();
				RandomOn = true;
				break;
			case 3: // Gradient
				disableAllModes();
				hideAllControls();
				setDefaultDefaults(255, 127);
				showGradientControls();
				GradientOn = true;
				break;
			case 4: // Velocity
				disableAllModes();
				hideAllControls();
				setDefaultDefaults(255, 127);
				showVelocityControls();
				VelocityOn = true;
				break;
			case 5: // Split
				disableAllModes();
				hideAllControls();
				setDefaultDefaults(255, 127);
				showSplitControls();
				SplitOn = true;
				break;
			case 6: // Animation
				disableAllModes();
				hideAllControls();
				showAnimationControls();
				setAnimationDefaults(0, 127);
				AnimationOn = true;
				break;
			case 7: // PianoRoll
				disableAllModes();
				hideAllControls();
				showPianoRollControls();
				LearnMidiOn = true;
				break;
			}
			println("Selected mode: " + m.get(n));
		} else {
			println("cp5 object is null");
		}
	}

	public void Open() {

		if (cp5.getController("Open").getCaptionLabel().getText().equals("Open")) {
			try {
				myBusIn = new MidiBus(this, midiName, 0);
				myBusOut = new MidiBus(this, midiOutName, 0);
				println("Midi Input Port Open: " + midiName);
				arduino = new Serial(this, portName, 115200);
				println("Serial Port Open : " + portName);
				cp5.getController("Open").getCaptionLabel().setText("Close");
				cp5.getController("Open").setColorBackground(color(0, 255, 0));

				sendCommandBlackOut();
				Toggle bg = (Toggle) cp5.getController("BGColor");
				BGColor(bg.getState());
				int fadeRate = (int) cp5.getController("FadeOnVal").getValue();
				sendCommandFadeRate(fadeRate);
				Toggle sd = (Toggle) cp5.getController("stripDirection");
				stripDirection(sd.getState());
			} catch (Exception e) {
				println("Error opening serial port: " + e.getMessage());
			}
		} else {
			if (arduino != null) {
				myBusIn.dispose();
				myBusOut.dispose();
				sendCommandBlackOut();
				BGColor(false);
				arduino.stop();
				println("Device closed: " + portName);
				println("Device closed: " + midiName);
				cp5.getController("Open").getCaptionLabel().setText("Open");
				cp5.getController("Open").setColorBackground(color(0, 0, 0));
			}
		}
	}

//was float
	public void FadeOnVal(int value) {
		sendCommandFadeRate((int) value);
	}

//was float
	public void Brightness(int value) {
		sendCommandBrightness((int) value);
	}

	public void Refresh() {

		if (os.contains("win")) {
			findPortNameOnWindows("Arduino");
		} else {
			findPortNameOnLinux("ttyACM");
		}
		refreshComList();
		refreshMidiList();
	}

	public void findPortNameOnWindows(String deviceName) {
		String[] cmd = { "cmd", "/c",
				"wmic path Win32_PnPEntity where \"Caption like '%(COM%)'\" get Caption /format:table" };
		portName = null;
		try {
			Process p = Runtime.getRuntime().exec(cmd);
			BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
			String line;
			while ((line = reader.readLine()) != null) {
				if (line.contains(deviceName)) {
					String[] tokens = line.split("\\s+");
					portName = tokens[tokens.length - 1].replaceAll("[()]", "");
					println("Device found: " + line);
					break;
				}
			}
			reader.close();
		} catch (IOException e) {
			println("Error: " + e.getMessage());
		}
	}

	public void findPortNameOnLinux(String deviceName) {
		String[] cmd = { "sh", "-c", "dmesg | grep " + deviceName };
		portName = null;
		Pattern pattern = Pattern.compile(deviceName + "(\\d+)");
		try {
			Process p = Runtime.getRuntime().exec(cmd);
			BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
			String line;
			while ((line = reader.readLine()) != null) {
				Matcher matcher = pattern.matcher(line);
				if (matcher.find()) {
					portName = "/dev/" + matcher.group(0);
					println("Device found: " + portName);
					break;
				}
			}
			reader.close();
		} catch (IOException e) {
			println("Error: " + e.getMessage());
		}
	}

	public void refreshComList() {
		comlist = Serial.list();
		cp5.get(ScrollableList.class, "comlist").clear();
		cp5.get(ScrollableList.class, "comlist").addItems(comlist);

		int portIndex = Arrays.asList(comlist).indexOf(portName);
		if (portIndex >= 0) {
			cp5.get(ScrollableList.class, "comlist").setValue(portIndex);
		}
	}

	public void refreshMidiList() {
		midilist.clear();
		midioutlist.clear();

		MidiDevice.Info[] info_midiIn = MidiSystem.getMidiDeviceInfo();
		for (MidiDevice.Info info : info_midiIn) {
			try {
				MidiDevice device = MidiSystem.getMidiDevice(info);
				if (device.getMaxTransmitters() != 0) {
					midilist.add(info.getName());
				}
				device.close();
			} catch (MidiUnavailableException e) {
				// Handle the exception
			}
		}

		MidiDevice.Info[] info_midiOut = MidiSystem.getMidiDeviceInfo();
		for (MidiDevice.Info info : info_midiOut) {
			try {
				MidiDevice device = MidiSystem.getMidiDevice(info);
				if (device.getMaxReceivers() != 0) {
					midioutlist.add(info.getName());
				}
				device.close();
			} catch (MidiUnavailableException e) {
				// Handle the exception
			}
		}
		cp5.get(ScrollableList.class, "midi").clear();
		cp5.get(ScrollableList.class, "midi").addItems(midilist);
		cp5.get(ScrollableList.class, "midi").setValue(findDefaultMidi(midilist, Arrays.asList("piano", "midi")));

		cp5.get(ScrollableList.class, "midiout").clear();
		cp5.get(ScrollableList.class, "midiout").addItems(midioutlist);
		cp5.get(ScrollableList.class, "midiout").setValue(findDefaultMidi(midioutlist, Arrays.asList("piano", "midi")));
	}

	public int findDefaultMidi(List<String> values, List<String> keywords) {
		int index = 0;
		for (String value : values) {
			for (String keyword : keywords) {
				if (value.toLowerCase().contains(keyword)) {
					return index;
				}
			}
			index++;
		}
		return 0;
	}

	public void CheckForUpdate() {
		checkForUpdates();
	}

//Instruction Buttton
	public void Instructions() {
		if (newWindowFrame == null) {
			// create a new window frame
			newWindowFrame = new JFrame("Instructions");
			newWindowFrame.setSize(600, 600);
			newWindowFrame.setLocationRelativeTo(null);
			newWindowFrame.setResizable(false);
			// create a JTextArea object and add it to a JScrollPane
			JTextArea textArea = new JTextArea("Short Instructions for PianoLED\n\n"
					+ "Your Arduino and MIDI devices should be auto selected all you have to do is click open\n"
					+ "to start using PianoLED.\n"
					+ "\nMake sure you upload the ArduinoPianoLED.ino file before using PianoLED app.\n"
					+ "\nFixLED: Fixes the leds position if you your strip is soldered together and not a single strip.\n"
					+ "\nReverse: Reverses the led strip directions useful if the default is not ideal for your setup.\n"
					+ "\nBG: Turns on background color for all modes,color and brightness adjustable.\n"
					+ "\nAvailable modes:\n"
					+ "- Default: Single led based control,fade rate, brightness & color can be adjusted\n"
					+ " with ui sliders,color wheel and premade color presets.\n"
					+ "- Splash: Multiple leds light up,fade rate, brightness,tail length & color can be adjusted.\n"
					+ "- Random: Single led based control, this time random colors only, fade & brightness still\n"
					+ "adjustable.\n"
					+ "- Gradient: Three new buttons Set LG,MG,RG each setting color for corresponding sides.\n"
					+ "Make sure you select color & set that as side color with LG,MG.RG buttons.If middle side\n"
					+ "color is not set the gradient will work in two sides color mode.\n"
					+ "\n- Velocity: Based on how hard the user is playing the notes,the single led will light up\n"
					+ "differently.\n"
					+ "- Split: Splits the led strip into two sides. The split point can be set by clicking on the key\n"
					+ "in the piano UI.\n"
					+ "\nMake sure you select color first,set the sides color with Set L, R & chose your split point.\n"
					+ "\nAnimation: Led strip lights up depending on what animation preset you selected.\n"
					+ "\nThat's all if you need more help check out the discord server for help & updates:\n"
					+ "discord: https://discord.com/invite/S6xmuX4Hx5\n"
					+ "\nPianoLED Â© 2023 by serifpersia. All rights reserved\n");
			textArea.setBackground(Color.BLACK);
			textArea.setForeground(Color.WHITE);
			textArea.setFont(new Font("Arial", Font.PLAIN, 14));
			JScrollPane scrollPane = new JScrollPane(textArea);
			newWindowFrame.add(scrollPane);
			newWindowFrame.addWindowListener(new java.awt.event.WindowAdapter() {
				public void windowClosing(java.awt.event.WindowEvent e) {
					newWindowFrame.dispose();
					newWindowFrame = null;
				}
			});
			newWindowFrame.setVisible(true);
		}
	}

	public void setLeftSide() {
		splitLeftRed = (Red);
		splitLeftGreen = (Green);
		splitLeftBlue = (Blue);
	}

	public void setRightSide() {
		splitRightRed = (Red);
		splitRightGreen = (Green);
		splitRightBlue = (Blue);
	}

	public void setLeftSideG() {
		LeftSideGRed = (Red);
		LeftSideGGreen = (Green);
		LeftSideGBlue = (Blue);
	}

	public void setMiddleSideG() {
		MiddleSideGRed = (Red);
		MiddleSideGGreen = (Green);
		MiddleSideGBlue = (Blue);
	}

	public void setRightSideG() {
		RightSideGRed = (Red);
		RightSideGGreen = (Green);
		RightSideGBlue = (Blue);
	}

	public void mousePressed() {
		for (int i = 0; i < whiteKeys.length; i++) {
			// Check if the mouse click was inside a white key
			if (mouseX > i * 15 + 15 && mouseX < (i + 1) * 15 + 15 && mouseY > 64 && mouseY < 134) {
				leftMaxPitch = whiteKeyPitches[i];
				Keys[whiteKeys[i]][0] = 1;
				println("Left Max Pitch: " + leftMaxPitch);
			}
		}
	}

	public void mouseReleased() {
		for (int i = 0; i < whiteKeys.length; i++) {
			// Check if the mouse click was inside a white key
			if (mouseX > i * 15 + 15 && mouseX < (i + 1) * 15 + 15 && mouseY > 64 && mouseY < 134) {
				// Change the color of the clicked key back to white
				Keys[whiteKeys[i]][0] = 0;
			}
		}
	}

	public void keyPressed() {

		if (key == 'l') {
			PianoRollLoadMidi();
		} else if (key == ' ') {
			PianoRollPlayPause();
		} else if (key == CODED) {
			if (keyCode == UP) {
				PianoRollRewind();
			} else if (keyCode == LEFT) {
				PianoRollBackwardFragment();
			} else if (keyCode == RIGHT) {
				PianoRollForwardFragment();
			}
		}
	}

	public void PianoRollPlayPause() {
		if (pianoRoll != null)
			pianoRoll.pause();
		Button button = cp5.get(Button.class, "PianoRollPlayPause");
		if (pianoRoll.isPaused()) {
			button.getCaptionLabel().setText(">");
			button.setColorBackground(BLUE);
		} else {
			button.getCaptionLabel().setText("||");
			button.setColorBackground(GREEN);
		}
	}

	public void PianoRollRewind() {
		if (pianoRoll != null)
			pianoRoll.rewind();
	}

	public void PianoRollForwardFragment() {
		if (pianoRoll != null)
			pianoRoll.rewind(PianoRoll.REWIND_FRAGMENT_SEC);
	}

	public void PianoRollBackwardFragment() {
		if (pianoRoll != null)
			pianoRoll.rewind(-PianoRoll.REWIND_FRAGMENT_SEC);
	}

	public void PianoRollLoadMidi() {
		// Use a file chooser dialog box to get the MIDI file to play
		JFileChooser chooser = new JFileChooser();
		chooser.setCurrentDirectory(new File("."));

		// Add a file filter to only allow MIDI files
		FileFilter filter = new FileFilter() {
			public boolean accept(File file) {
				String filename = file.getName().toLowerCase();
				return filename.endsWith(".mid") || filename.endsWith(".midi") || file.isDirectory();
			}

			public String getDescription() {
				return "MIDI files (*.mid, *.midi)";
			}
		};
		chooser.setFileFilter(filter);

		int result = chooser.showOpenDialog(null);
		if (result == JFileChooser.APPROVE_OPTION) {
			File midiFile = chooser.getSelectedFile();

			try {

				// Get the selected MIDI output device
				int midiOutIndex = (int) cp5.get(ScrollableList.class, "midiout").getValue();
				MidiDevice.Info[] midiOutDeviceInfo = MidiSystem.getMidiDeviceInfo();
				MidiDevice midiOutDevice = MidiSystem.getMidiDevice(midiOutDeviceInfo[midiOutIndex]);
				surface.setSize(PIANO_ROLL_HEIGHT, PIANO_ROLL_WIDTH);
				pianoRoll = new PianoRoll(this, midiFile, midiOutDevice);
			} catch (Exception ex) {
				ex.printStackTrace();
			}
		}
	}

	public static void printArray(byte[] bytes) {
		print("Message:");
		for (byte b : bytes) {
			int unsignedValue = b & 0xFF;
			print(unsignedValue + " ");
		}
		println();
	}

	public void dispose() {
		try {
			sendCommandBlackOut();
			sendCommandSetBG(0, 0, 0);
			if (myBusIn != null && myBusOut != null) {
				myBusIn.dispose();
				myBusOut.dispose();
			}
			if (arduino != null) {
				arduino.stop();
			}
		} catch (Exception e) {
			println("Error while exiting: " + e);
		}
		exit();
	}

	public void setAnimationDefaults(int fadeRate, int brightness) {
		cp5.getController("FadeOnVal").setValue(fadeRate);
		cp5.getController("Brightness").setValue(brightness);
		cp5.getController("Brightness").setPosition(EFFECT_CONTROLS_X - 15, 65);
	}
//command start with 3 bytes: COMMAND_BYTE1 | COMMAND_BYTE2 | EFFECT_COMMAND
//then goes effect bytes

	final static byte COMMAND_BYTE1 = (byte) 111;
	final static byte COMMAND_BYTE2 = (byte) 222;

	final static byte COMMAND_SET_COLOR = (byte) 255;
	final static byte COMMAND_FADE_RATE = (byte) 254;
	final static byte COMMAND_ANIMATION = (byte) 253;
	final static byte COMMAND_BLACKOUT = (byte) 252;
	final static byte COMMAND_SPLASH = (byte) 251;
	final static byte COMMAND_SET_BRIGHTNESS = (byte) 250;
	final static byte COMMAND_KEY_OFF = (byte) 249;
	final static byte COMMAND_SPLASH_MAX_LENGTH = (byte) 248;
	final static byte COMMAND_SET_BG = (byte) 247;
	final static byte COMMAND_VELOCITY = (byte) 246;
	final static byte COMMAND_STRIP_DIRECTION = (byte) 245;

	public ByteArrayOutputStream commandSetColor(int r, int g, int b, int note) {
		ByteArrayOutputStream message = new ByteArrayOutputStream();
		message.write((byte) COMMAND_BYTE1);
		message.write((byte) COMMAND_BYTE2);
		message.write((byte) COMMAND_SET_COLOR);
		message.write((byte) r);
		message.write((byte) g);
		message.write((byte) b);
		message.write((byte) note);
		return message;
	}

	public ByteArrayOutputStream commandSetBrightness(int brightness) {
		ByteArrayOutputStream message = new ByteArrayOutputStream();
		message.write((byte) COMMAND_BYTE1);
		message.write((byte) COMMAND_BYTE2);
		message.write((byte) COMMAND_SET_BRIGHTNESS);
		message.write((byte) brightness);
		return message;
	}

	public ByteArrayOutputStream commandSplash(int velocity, int note, int sc) {
		ByteArrayOutputStream message = new ByteArrayOutputStream();
		message.write((byte) COMMAND_BYTE1);
		message.write((byte) COMMAND_BYTE2);
		message.write((byte) COMMAND_SPLASH);
		message.write((byte) velocity);
		message.write((byte) note);
		message.write((byte) red(sc));
		message.write((byte) green(sc));
		message.write((byte) blue(sc));
		return message;
	}

	public ByteArrayOutputStream commandFadeRate(int fadeRate) {
		ByteArrayOutputStream message = new ByteArrayOutputStream();
		message.write((byte) COMMAND_BYTE1);
		message.write((byte) COMMAND_BYTE2);
		message.write((byte) COMMAND_FADE_RATE);
		message.write((byte) fadeRate);
		return message;
	}

	public ByteArrayOutputStream commandAnimation(int animationIndex) {
		ByteArrayOutputStream message = new ByteArrayOutputStream();
		message.write((byte) COMMAND_BYTE1);
		message.write((byte) COMMAND_BYTE2);
		message.write((byte) COMMAND_ANIMATION);
		message.write((byte) animationIndex);
		return message;
	}

	public ByteArrayOutputStream commandBlackOut() {
		ByteArrayOutputStream message = new ByteArrayOutputStream();
		message.write((byte) COMMAND_BYTE1);
		message.write((byte) COMMAND_BYTE2);
		message.write((byte) COMMAND_BLACKOUT);
		return message;
	}

	public ByteArrayOutputStream commandKeyOff(int note) {
		ByteArrayOutputStream message = new ByteArrayOutputStream();
		message.write((byte) COMMAND_BYTE1);
		message.write((byte) COMMAND_BYTE2);
		message.write((byte) COMMAND_KEY_OFF);
		message.write((byte) note);
		return message;
	}

	public ByteArrayOutputStream commandSplashMaxLength(int value) {
		ByteArrayOutputStream message = new ByteArrayOutputStream();
		message.write((byte) COMMAND_BYTE1);
		message.write((byte) COMMAND_BYTE2);
		message.write((byte) COMMAND_SPLASH_MAX_LENGTH);
		message.write((byte) value);
		return message;
	}

	public ByteArrayOutputStream commandSetBG(int hue, int saturation, int brightness) {
		ByteArrayOutputStream message = new ByteArrayOutputStream();
		message.write((byte) COMMAND_BYTE1);
		message.write((byte) COMMAND_BYTE2);
		message.write((byte) COMMAND_SET_BG);
		message.write((byte) hue);
		message.write((byte) saturation);
		message.write((byte) brightness);
		return message;
	}

	public ByteArrayOutputStream commandVelocity(int velocity, int note, int r, int g, int b) {
		ByteArrayOutputStream message = new ByteArrayOutputStream();
		message.write((byte) COMMAND_BYTE1);
		message.write((byte) COMMAND_BYTE2);
		message.write((byte) COMMAND_VELOCITY);
		message.write((byte) velocity);
		message.write((byte) note);
		message.write((byte) r);
		message.write((byte) g);
		message.write((byte) b);
		return message;
	}

	public ByteArrayOutputStream commandStripDirection(int direction, int numLeds) {
		ByteArrayOutputStream message = new ByteArrayOutputStream();
		message.write((byte) COMMAND_BYTE1);
		message.write((byte) COMMAND_BYTE2);
		message.write((byte) COMMAND_STRIP_DIRECTION);
		message.write((byte) direction);
		message.write((byte) numLeds);
		return message;
	}

	public void sendCommandAnimation(int animationIndex) {
		sendToArduino(commandAnimation(animationIndex));
	}

	public void sendCommandSplash(int velocity, int note, int sc) {
		sendToArduino(commandSplash(velocity, note, sc));
	}

	public void sendCommandBlackOut() {
		sendToArduino(commandBlackOut());
	}

	public void sendCommandBrightness(int value) {
		sendToArduino(commandSetBrightness(value));
	}

	public void sendCommandKeyOff(int value) {
		sendToArduino(commandKeyOff(value));
	}

	public void sendCommandFadeRate(int value) {
		sendToArduino(commandFadeRate(value));
	}

	public void sendCommandSplashMaxLength(int value) {
		sendToArduino(commandSplashMaxLength(value));
	}

	public void sendCommandSetBG(int hue, int saturation, int brightness) {
		sendToArduino(commandSetBG(hue, saturation, brightness));
	}

	public void sendCommandVelocity(int velocity, int note, int r, int g, int b) {
		sendToArduino(commandVelocity(velocity, note, r, g, b));
	}

	public void sendCommandStripDirection(int direction, int numLeds) {
		sendToArduino(commandStripDirection(direction, numLeds));
	}

	public void sendToArduino(byte val) {
		println("Arduino command: " + (int) (val & 0xFF));
		if (arduino != null) {
			arduino.write(val);
		}
	}

	public void sendToArduino(ByteArrayOutputStream msg) {
		if (arduino != null && arduino.active()) {
			byte[] bytes = msg.toByteArray();
			printArray(bytes);
			arduino.write(bytes);
		}
	}

	public void setDefaultDefaults(int fadeRate, int brightness) {
		cp5.getController("FadeOnVal").setValue(fadeRate);
		cp5.getController("Brightness").setValue(brightness);
		cp5.getController("Brightness").setPosition(EFFECT_CONTROLS_X - 4, 65);
	}

	public void splashMaxLength(float value) {
		sendCommandSplashMaxLength((int) value);
	}

	public void setSplashDefaults(int splashLen, int fadeRate, int splashColor, int brightness) {
		cp5.getController("splashMaxLength").setValue(splashLen);
		cp5.getController("FadeOnVal").setValue(fadeRate);
		cp5.get(ScrollableList.class, "splashColor").setValue(splashColor);
		cp5.getController("Brightness").setValue(brightness);
	}

	public void splashColor(int n) {
		int first = 0;
		int last = splashColorNames.size() - 1;
		if (n > first && n < last) {
			cp5.get(ColorWheel.class, "Color").setRGB(presetColors[n - 1]);
		}
	}

	public int getSplashColor() {
		int n = (int) cp5.get(ScrollableList.class, "splashColor").getValue();
		int first = 0;
		int splashColor;
		int last = splashColorNames.size() - 1;
		if (n == first) {
			// Full Spectrum mode
			splashColor = color(0, 0, 0);
			println("Selected color: Full Spectrum");
		} else if (n > first && n < last) {
			// Preset color mode
			splashColor = presetColors[n - 1];
			println("Selected color: " + colorNames.get(n - 1));

		} else if (n == last) {
			// Manual
			splashColor = cp5.get(ColorWheel.class, "Color").getRGB();
		} else {
			// Invalid color mode
			println("Invalid color selection: " + n);
			return 0;
		}
		return splashColor;
	}

	ControlP5 cp5;

	int MIN_FADE_RATE = 0;
	int MAX_FADE_RATE = 255;
	int DEFAULT_FADE_RATE = 255;

	int RED = color(255, 0, 0);
	int DARK_GREEN = color(0, 200, 0);
	int GREEN = color(0, 255, 0);
	int LAVENDER = color(192, 128, 255);
	int BLUE = color(0, 0, 255);
	int BLACK = color(0, 0, 0);
	int WHITE = color(255, 255, 255);
	int GREY = color(150, 150, 150);
	int YELLOW = color(255, 255, 0);
	int MAGENTA = color(255, 0, 255);

	int APP_COLOR_FG = RED;
	int APP_COLOR_BG = BLACK;
	int APP_COLOR_ACT = RED;

	int SLIDER_COLOR_FG = GREY;
	int SLIDER_COLOR_BG = BLACK;
	int SLIDER_COLOR_ACT = GREY;

	int MIN_BRIGHT = 0;
	int MAX_BRIGHT = 255;
	int DEF_BRIGHT = 127;

	int MIN_COLOR = 0;
	int MAX_COLOR = 255;
	int DEF_COLOR = MAX_COLOR;
	int EFFECT_CONTROLS_X = 811;

	int Red = MAX_COLOR, Green = MAX_COLOR, Blue = MAX_COLOR, Brightness = MAX_COLOR, FadeOnVal = MAX_COLOR,
			velRedL = MAX_COLOR, velGreenL = MAX_COLOR, velBlueL = MAX_COLOR, velRedLM = MAX_COLOR,
			velGreenLM = MAX_COLOR, velBlueLM = MAX_COLOR, velRedM = MAX_COLOR, velGreenM = MAX_COLOR,
			velBlueM = MAX_COLOR, velRedH = MAX_COLOR, velGreenH = MAX_COLOR, velBlueH = MAX_COLOR,
			splitLeftRed = MAX_COLOR, splitLeftGreen = MAX_COLOR, splitLeftBlue = MAX_COLOR, splitRightRed = MAX_COLOR,
			splitRightGreen = MAX_COLOR, splitRightBlue = MAX_COLOR, LeftSideGRed = 0, LeftSideGGreen = 0,
			LeftSideGBlue = 0, RightSideGRed = 0, RightSideGGreen = 0, RightSideGBlue = 0, MiddleSideGRed = 0,
			MiddleSideGGreen = 0, MiddleSideGBlue = 0;

	int splashRed = 0;
	int splashGreen = 0;
	int splashBlue = 0;

	int[] presetColors = { color(255, 0, 0), // Red
			color(0, 255, 0), // Green
			color(0, 0, 255), // Blue
			color(255, 255, 0), // Yellow
			color(255, 128, 0), // Orange
			color(128, 0, 255), // Purple
			color(255, 0, 255), // Pink
			color(0, 255, 255), // Teal
			color(128, 255, 0), // Lime
			color(0, 255, 128), // Cyan
			color(255, 0, 128), // Magenta
			color(255, 128, 128), // Peach
			color(192, 128, 255), // Lavender
			color(128, 192, 192), // Turquoise
			color(255, 215, 0) // Gold
	};

	List<String> colorNames = Arrays.asList("Red", "Green", "Blue", "Yellow", "Orange", "Purple", "Pink", "Teal",
			"Lime", "Cyan", "Magenta", "Peach", "Lavender", "Turquoise", "Gold");
	List<String> splashColorNames = Arrays.asList("Full Spectrum", "Red", "Green", "Blue", "Yellow", "Orange", "Purple",
			"Pink", "Teal", "Lime", "Cyan", "Magenta", "Peach", "Lavender", "Turquoise", "Gold", "Manual");
	List<String> animationNames = Arrays.asList("RainbowColors", "RainbowStripeColor", "OceanColors", "CloudColors",
			"LavaColors", "ForestColors", "PartyColors");

	public ControlP5 buildUI() {
		ControlP5 cp5 = new ControlP5(this);

		addSlider(cp5, "Brightness", "  B", EFFECT_CONTROLS_X - 4, 65, 10, 69, MIN_BRIGHT, MAX_BRIGHT, DEF_BRIGHT, BLUE,
				BLACK, RED)
		// .setLabelVisible(false)
		;

		addSlider(cp5, "FadeOnVal", "  F", EFFECT_CONTROLS_X - 15, 65, 10, 69, MIN_FADE_RATE, MAX_FADE_RATE,
				DEFAULT_FADE_RATE, DARK_GREEN, BLACK, RED)
		// .setLabelVisible(false)
		;

		addButton(cp5, "CheckForUpdate", "Update", 620, 20, 45, 25);

		addButton(cp5, "setLeftSideG", "Set LG", 705, 140, 30, 15).hide();
		addButton(cp5, "setMiddleSideG", "Set MG", 735, 140, 30, 15).hide();
		addButton(cp5, "setRightSideG", "Set RG", 765, 140, 30, 15).hide();

		addButton(cp5, "setLeftSide", "Set L", 735, 140, 30, 15).hide();
		addButton(cp5, "setRightSide", "Set R", 765, 140, 30, 15).hide();

		addButton(cp5, "setBG", "Set BG", 670, 26, 30, 15).hide();

		addButton(cp5, "Open", null, 725, 45, 50, 15);
		addButton(cp5, "Refresh", null, 775, 45, 50, 15);

		addColorWheel(cp5, "Color", EFFECT_CONTROLS_X + 15, 45, 100);

		addAnimationControls(cp5);

		addButton(cp5, "leftArrow", "<", 380, 25, 30, 15, APP_COLOR_FG, BLUE, APP_COLOR_ACT);
		addButton(cp5, "rightArrow", ">", 415, 25, 30, 15, APP_COLOR_FG, BLUE, APP_COLOR_ACT);

		// addButton(cp5, "AdvanceUser", null, 15, 15, 60, 15);

		int SPLASH_CONTROL_X = EFFECT_CONTROLS_X + 6;
		int SPLASH_CONTROL_Y = 60;
		addSplashControls(cp5, SPLASH_CONTROL_X, SPLASH_CONTROL_Y);
		addPianoRollControls(cp5, EFFECT_CONTROLS_X + 10, 30);
		addButton(cp5, "Instructions", null, 15, 15, 60, 15);

		addToggle(cp5, "BGColor", " BG", 700, 25, 15, 15, RED, WHITE, GREEN);
		addToggle(cp5, "stripDirection", "Reverse", 425, 42, 10, 8, RED, WHITE, GREEN).getCaptionLabel()
				.alignX(ControlP5.CENTER);
		addToggle(cp5, "Fix", "Fix LED", 390, 42, 10, 8, RED, WHITE, GREEN).getCaptionLabel().alignX(ControlP5.CENTER);

		addScrollableList(cp5, "comlist", "Arduino Port", null, -1, 725, 15, 100, 110, 15, 15).close();
		addScrollableList(cp5, "midi", "Midi Device", null, -1, 725, 30, 100, 110, 15, 15).close();
		addScrollableList(cp5, "colorlist", "Color Preset", colorNames, 0, EFFECT_CONTROLS_X + 15, 30, 100, 100, 15,
				15);
		addScrollableList(cp5, "modelist", "Mode", m, 0, EFFECT_CONTROLS_X + 15, 15, 100, 100, 15, 15).bringToFront();

		return cp5;
	}

	public void addPianoRollControls(ControlP5 cp5, int origX, int origY) {
		int x = origX;
		int y = origY;
		int h = 25;
		int w = 25;
		PFont font = createFont("Arial", 12);

		addScrollableList(cp5, "midiout", "Midi Output Device", null, -1, EFFECT_CONTROLS_X + 15, y, 100, 110, 15, 15);
		y += 25;
		addButton(cp5, "PianoRollLoadMidi", "Load Midi File", EFFECT_CONTROLS_X + 15, y, 100, 15).hide();
		y += 25;
		addButton(cp5, "PianoRollRewind", "|<<", x, y, h, w, RED, BLUE, GREEN).hide().getCaptionLabel().setFont(font);
		x += w + 2;
		addButton(cp5, "PianoRollBackwardFragment", "-" + PianoRoll.REWIND_FRAGMENT_SEC, x, y, h, w, RED, BLUE, GREEN)
				.hide().getCaptionLabel().setFont(font);
		x += w + 2;
		addButton(cp5, "PianoRollPlayPause", ">", x, y, h, w, RED, BLUE, GREEN).hide().getCaptionLabel().setFont(font);
		x += w + 2;
		addButton(cp5, "PianoRollForwardFragment", "+" + PianoRoll.REWIND_FRAGMENT_SEC, x, y, h, w, RED, BLUE, GREEN)
				.hide().getCaptionLabel().setFont(font);
		x = origX;
		y += h + 5;
		// addToggle(cp5, "PianoRollFollowKey", "Teacher Mode", x, y, 15, 15, RED,
		// WHITE, GREEN).hide();

		cp5.getController("midiout").bringToFront();
	}

	public void addSplashControls(ControlP5 cp5, int x, int y) {
		int SPLASH_MIN_LEN = 5;
		int SPLASH_MAX_LEN = 15;
		int SPLASH_DEFAULT_LEN = 8;

		int SPLASH_MIN_TAIL_FADE = 1;
		int SPLASH_MAX_TAIL_FADE = 50;
		int SPLASH_DAFAULT_TAIL_FADE = 15;

		int SPLASH_MIN_VELO_BRI = 5;
		int SPLASH_MAX_VELO_BRI = 15;
		int SPLASH_DAFAULT_VELO_BRI = 10;

		int SPLASH_MIN_VELO_SPEED = 5;
		int SPLASH_MAX_VELO_SPEED = 15;
		int SPLASH_DAFAULT_VELO_SPEED = 10;

		int SPLASH_CONTROL_Y_STEP = 13;

		addSlider(cp5, "splashMaxLength", "  L", EFFECT_CONTROLS_X + 7, 65, 10, 69, SPLASH_MIN_LEN, SPLASH_MAX_LEN,
				SPLASH_DEFAULT_LEN, LAVENDER, BLACK, RED).hide();
		y += SPLASH_CONTROL_Y_STEP;

		addScrollableList(cp5, "splashColor", "Color", splashColorNames, 0, EFFECT_CONTROLS_X + 15, 30, 100, 100, 15,
				15).hide();
		y += SPLASH_CONTROL_Y_STEP;

		addSlider(cp5, "splashTailFade", "Tail Fade Rate", x, y, SPLASH_MIN_TAIL_FADE, SPLASH_MAX_TAIL_FADE,
				SPLASH_DAFAULT_TAIL_FADE).hide();
		y += SPLASH_CONTROL_Y_STEP;

		// addSlider( cp5, "splashHeadFade", "Head Fade Rate", x, y,
		// SPLASH_MIN_HEAD_FADE, SPLASH_MAX_HEAD_FADE, SPLASH_DAFAULT_HEAD_FADE).hide();
		// y += SPLASH_CONTROL_Y_STEP;

		addSlider(cp5, "splashVelocityBrightnessImpact", "Velocity To Bright", x, y, SPLASH_MIN_VELO_BRI,
				SPLASH_MAX_VELO_BRI, SPLASH_DAFAULT_VELO_BRI).hide();
		y += SPLASH_CONTROL_Y_STEP;

		addSlider(cp5, "splashVelocitySpeedImpact", "Velocity To Speed", x, y, SPLASH_MIN_VELO_SPEED,
				SPLASH_MAX_VELO_SPEED, SPLASH_DAFAULT_VELO_SPEED).hide();
		y += SPLASH_CONTROL_Y_STEP;
	}

	public void addAnimationControls(ControlP5 cp5) {
		addScrollableList(cp5, "animationlist", "Animations", animationNames, 0, EFFECT_CONTROLS_X + 15, 30, 100, 100,
				15, 15).hide();
	}

	int[][] Keys = new int[88][2];
	int[][] Leds = new int[88][2];
	int rectASizeX = 0;
	int rectBSizeX = 0;
	int rectBX = 795;

	public void leftArrow() {
		if (counter <= 0) {
			numberselected = 176;
			firstNoteSelected = 21;
			lastNoteSelected = 108;
			return;
		}
		counter--; // increment counter each time button is pressed
		println("counter: " + counter);
		if (counter == 3) {
			rectASizeX = 135;
			rectBSizeX += 105;
			numberselected = 122;
			firstNoteSelected = 36;
			lastNoteSelected = 96;
			println("Selected number led: " + numberselected);
			println("Selected first note: " + firstNoteSelected);
			println("Selected last note: " + lastNoteSelected);
		}
		if (counter == 2) {
			rectASizeX -= 75;
			rectBSizeX += 30;
			numberselected = 146;
			firstNoteSelected = 28;
			lastNoteSelected = 100;
			println("Selected number led: " + numberselected);
			println("Selected first note: " + firstNoteSelected);
			println("Selected last note: " + lastNoteSelected);
		}
		if (counter == 1) {
			rectASizeX = 60;
			rectBSizeX += 30;
			numberselected = 152;
			firstNoteSelected = 28;
			lastNoteSelected = 103;
			println("Selected number led: " + numberselected);
			println("Selected first note: " + firstNoteSelected);
			println("Selected last note: " + lastNoteSelected);
		}
		if (counter == 0) {
			rectASizeX -= 60;
			rectBSizeX -= 60;
			numberselected = 176;
			firstNoteSelected = 21;
			lastNoteSelected = 108;
			println("Selected number led: " + numberselected);
			println("Selected first note: " + firstNoteSelected);
			println("Selected last note: " + lastNoteSelected);
		}
		if (counter == 0) {
			rectASizeX = 0;
			rectBSizeX = 0;
		}
	}

	public void rightArrow() {
		if (counter >= 4) {
			return;
		}
		counter++; // increment counter each time button is pressed
		println("counter: " + counter);
		if (counter == 0) {
			rectASizeX = 0;
			rectBSizeX = 0;
			numberselected = 176;
			firstNoteSelected = 21;
			lastNoteSelected = 108;
		}
		if (counter == 1) {
			rectASizeX += 60;
			rectBSizeX -= 45;
			numberselected = 152;
			firstNoteSelected = 28;
			lastNoteSelected = 103;
		}

		if (counter == 2) {
			rectASizeX = +60;
			rectBSizeX -= 30;
			numberselected = 146;
			firstNoteSelected = 28;
			lastNoteSelected = 100;
		}
		if (counter == 3) {
			rectASizeX = 135;
			rectBSizeX -= 30;
			numberselected = 122;
			firstNoteSelected = 36;
			lastNoteSelected = 96;
		}
		if (counter == 4) {
			rectASizeX = 135;
			rectBSizeX -= 105;
			numberselected = 98;
			firstNoteSelected = 36;
			lastNoteSelected = 84;
		}
		println("Selected number led: " + numberselected);
		println("Selected first note: " + firstNoteSelected);
		println("Selected last note: " + lastNoteSelected);
	}

	public void hideAllControls() {
		hideBGControls();
		hideDefaultControls();
		hideSplashControls();
		hideRandomControls();
		hideGradientControls();
		hideVelocityControls();
		hideSplitControls();
		hideAnimationControls();
		hidePianoRollControls();
		hidePianoRoll();
	}

	public void hidePianoRoll() {
		pianoRoll = null;
		surface.setSize(930, 160);
	}

//BG Controls
	public void showBGControls() {
		setControllersVisible(getBGControllers(), true);
	}

	public void hideBGControls() {
		setControllersVisible(getBGControllers(), false);
	}

//Default Controls
	public void showDefaultControls() {
		setControllersVisible(getDefaultControllers(), true);
	}

	public void hideDefaultControls() {
		setControllersVisible(getDefaultControllers(), false);
	}

//Splash Controls
	public void showSplashControls() {
		setControllersVisible(getSplashControllers(), true);
		cp5.getController("modelist");
	}

	public void hideSplashControls() {
		setControllersVisible(getSplashControllers(), false);
	}

//Random Controls
	public void showRandomControls() {
		setControllersVisible(getRandomControllers(), true);
	}

	public void hideRandomControls() {
		setControllersVisible(getRandomControllers(), false);
	}

//Gradient Controls
	public void showGradientControls() {
		setControllersVisible(getGradinetControllers(), true);
	}

	public void hideGradientControls() {
		setControllersVisible(getGradinetControllers(), false);
	}

//Velocity Controls
	public void showVelocityControls() {
		setControllersVisible(getVelocityControllers(), true);
	}

	public void hideVelocityControls() {
		setControllersVisible(getVelocityControllers(), false);
	}

//Split Controls
	public void showSplitControls() {
		setControllersVisible(getSplitControllers(), true);
	}

	public void hideSplitControls() {
		setControllersVisible(getSplitControllers(), false);
	}

//Animation Controls
	public void showAnimationControls() {
		setControllersVisible(getAnimationControllers(), true);
	}

	public void hideAnimationControls() {
		setControllersVisible(getAnimationControllers(), false);
	}

//LearnMidi Controls
	public void showPianoRollControls() {
		setControllersVisible(getPianoRollControllers(), true);
	}

	public void hidePianoRollControls() {
		setControllersVisible(getPianoRollControllers(), false);
	}

	public void Color(int rgb) {
		Red = (int) red(rgb);
		Green = (int) green(rgb);
		Blue = (int) blue(rgb);
		cp5.get(ScrollableList.class, "splashColor").setValue(splashColorNames.size() - 1);
		println("Colors: RED" + Red + ", GREEN" + Green + ", BLUE" + Blue);
	}

//BG List
	@SuppressWarnings("rawtypes")
	public List<Controller> getBGControllers() {
		if (cp5 == null)
			return null;

		List<Controller> cl = new ArrayList<>();
		cl.add(cp5.getController("setBG"));

		return cl;
	}

//Default List
	@SuppressWarnings("rawtypes")
	public List<Controller> getDefaultControllers() {
		if (cp5 == null)
			return null;

		List<Controller> cl = new ArrayList<>();
		cl.add(cp5.getController("Brightness"));
		cl.add(cp5.getController("FadeOnVal"));
		cl.add(cp5.getController("Color"));
		cl.add(cp5.getController("colorlist"));

		return cl;
	}

//Splash List
	@SuppressWarnings("rawtypes")
	public List<Controller> getSplashControllers() {
		if (cp5 == null)
			return null;

		List<Controller> cl = new ArrayList<>();
		cl.add(cp5.getController("splashMaxLength"));
		cl.add(cp5.getController("FadeOnVal"));
		cl.add(cp5.getController("Brightness"));
		cl.add(cp5.getController("splashHeadFade"));
		cl.add(cp5.getController("splashColor"));
		cl.add(cp5.getController("Color"));

		// cl.add(cp5.getController("splashVelocityBrightnessImpact"));
		// cl.add(cp5.getController("splashVelocitySpeedImpact"));
		return cl;
	}

//Random List
	@SuppressWarnings("rawtypes")
	public List<Controller> getRandomControllers() {
		if (cp5 == null)
			return null;

		List<Controller> cl = new ArrayList<>();

		cl.add(cp5.getController("Brightness"));
		cl.add(cp5.getController("FadeOnVal"));
		return cl;
	}

//Gradient List
	@SuppressWarnings("rawtypes")
	public List<Controller> getGradinetControllers() {
		if (cp5 == null)
			return null;

		List<Controller> cl = new ArrayList<>();

		cl.add(cp5.getController("Brightness"));
		cl.add(cp5.getController("FadeOnVal"));
		cl.add(cp5.getController("colorlist"));
		cl.add(cp5.getController("Color"));
		cl.add(cp5.getController("setLeftSideG"));
		cl.add(cp5.getController("setMiddleSideG"));
		cl.add(cp5.getController("setRightSideG"));

		return cl;
	}

//Velocity List
	@SuppressWarnings("rawtypes")
	public List<Controller> getVelocityControllers() {
		if (cp5 == null)
			return null;

		List<Controller> cl = new ArrayList<>();

		cl.add(cp5.getController("Brightness"));
		cl.add(cp5.getController("FadeOnVal"));

		return cl;
	}

//Split List
	@SuppressWarnings("rawtypes")
	public List<Controller> getSplitControllers() {
		if (cp5 == null)
			return null;

		List<Controller> cl = new ArrayList<>();

		cl.add(cp5.getController("Brightness"));
		cl.add(cp5.getController("FadeOnVal"));

		cl.add(cp5.getController("colorlist"));
		cl.add(cp5.getController("Color"));

		cl.add(cp5.getController("setLeftSide"));
		cl.add(cp5.getController("setRightSide"));
		return cl;
	}

//Animation List
	@SuppressWarnings("rawtypes")
	public List<Controller> getAnimationControllers() {
		if (cp5 == null)
			return null;

		List<Controller> cl = new ArrayList<>();

		cl.add(cp5.getController("Brightness"));
		cl.add(cp5.getController("animationlist"));

		return cl;
	}

//PianoRoll List
	@SuppressWarnings("rawtypes")
	public List<Controller> getPianoRollControllers() {
		if (cp5 == null)
			return null;

		List<Controller> cl = new ArrayList<>();

		cl.add(cp5.getController("midiout"));
		cl.add(cp5.getController("PianoRollLoadMidi"));
		cl.add(cp5.getController("PianoRollRewind"));
		cl.add(cp5.getController("PianoRollBackwardFragment"));
		cl.add(cp5.getController("PianoRollPlayPause"));
		cl.add(cp5.getController("PianoRollForwardFragment"));
		cl.add(cp5.getController("PianoRollFollowKey"));

		cp5.getController("midiout");
		return cl;
	}

	@SuppressWarnings("rawtypes")
	public void setControllersVisible(List<Controller> cl, boolean visible) {
		if (cl == null)
			return;
		for (Controller c : cl) {
			if (c != null) {
				c.setVisible(visible);
			}
		}
	}

	public void draw() {
		background(0);
		presetText = "Piano: ";
		if (firstNoteSelected == 21 && lastNoteSelected == 108) {
			presetText += "88 Keys";
		} else if (firstNoteSelected == 28 && lastNoteSelected == 103) {
			presetText += "76 Keys";
		} else if (firstNoteSelected == 28 && lastNoteSelected == 100) {
			presetText += "73 Keys";
		} else if (firstNoteSelected == 36 && lastNoteSelected == 96) {
			presetText += "61 Keys";
		} else if (firstNoteSelected == 36 && lastNoteSelected == 84) {
			presetText += "49 Keys";
		}

		// Piano type
		// PianoLED version tag uncomment when compiling to exe
		String VersionAppTag = "PianoLED: " + "v3.7";
		fill(255);
		text(presetText, 375, 15);
		text(VersionAppTag, 15, 150);

		// white keys
		// Initial x-coordinate of the first key
		int x = 0;
		for (int i = 0; i < whiteKeys.length; i++) {
			if (Keys[whiteKeys[i]][0] == 1) {
				fill(255, 0, 0);
			} else {
				fill(255);
			}
			// Draw the key at the current x-coordinate
			rect(x + 15, 64, 15, 70);
			fill(0);
			// Move the x-coordinate to the right by 10 pixels
			// to prepare for the next key
			x += 15;
		}
		// black keys
		for (int i = 0; i < blackKeys.length; i++) {
			if (Keys[blackKeys[i]][1] == 1) {
				fill(255, 0, 0);
			} else {
				fill(0);
			}
			// Use the x-coordinate from the list to draw each key
			rect(keyXCoordinates[i] + 15, 65, 8, 40);
		}
		// highlight piano size L&R boxes
		fill(0, 127);
		rect(15, 64, rectASizeX, 70);
		rect(rectBX, 64, rectBSizeX, 70);
		// block led strip with black color
		fill(0);
		rect(15, 54, rectASizeX, 10);
		rect(rectBX, 54, rectBSizeX, 10);

		if (pianoRoll != null) {
			pianoRoll.draw();
		}
	}

	int whiteKeyPitches[] = { 21, 23, 24, 26, 28, 29, 31, 33, 35, 36, 38, 40, 41, 43, 45, 47, 48, 50, 52, 53, 55, 57,
			59, 60, 62, 64, 65, 67, 69, 71, 72, 74, 76, 77, 79, 81, 83, 84, 86, 88, 89, 91, 93, 95, 96, 98, 100, 101,
			103, 105, 107, 108 };
// List of white keys in a 88-key piano
	int whiteKeys[] = { 0, 2, 3, 5, 7, 8, 10, 12, 14, 15, 17, 19, 20, 22, 24, 26, 27, 29, 31, 32, 34, 36, 38, 39, 41,
			43, 44, 46, 48, 50, 51, 53, 55, 56, 58, 60, 62, 63, 65, 67, 68, 70, 72, 74, 75, 77, 79, 80, 82, 84, 86,
			87 };
	int[] blackKeys = { 1, 4, 6, 9, 11, 13, 16, 18, 21, 23, 25, 28, 30, 33, 35, 37, 40, 42, 45, 47, 49, 52, 54, 57, 59,
			61, 64, 66, 69, 71, 73, 76, 78, 81, 83, 85 };
// Create a list of x-coordinates for each key
	int[] keyXCoordinates = { 11, 40, 56, 86, 101, 116, 145, 161, 191, 206, 221, 251, 266, 296, 311, 326, 356, 371, 401,
			416, 431, 461, 476, 506, 521, 536, 566, 581, 611, 626, 641, 671, 686, 715, 731, 746 };

//Buttons
	public Button addButton(ControlP5 cp5, String name, String label, int x, int y, int w, int h) {
		return addButton(cp5, name, label, x, y, w, h, APP_COLOR_FG, APP_COLOR_BG, APP_COLOR_ACT);
	}

	public Button addButton(ControlP5 cp5, String name, String label, int x, int y, int w, int h, int fg, int bg,
			int act) {
		Button b = cp5.addButton(name).setPosition(x, y);

		b.setColorForeground(fg);
		b.setColorBackground(bg);
		b.setColorActive(act);

		if (x > 0 && y > 0)
			b.setSize(w, h);
		if (label != null)
			b.setLabel(label);

		return b;
	}

// SCrollable List
	public ScrollableList addScrollableList(ControlP5 cp5, String name, String label, List<String> items, int defItem,
			int x, int y, int w, int h, int barH, int itemH) {
		return addScrollableList(cp5, name, label, items, defItem, x, y, w, h, barH, itemH, APP_COLOR_FG, APP_COLOR_BG,
				APP_COLOR_ACT);
	}

	public ScrollableList addScrollableList(ControlP5 cp5, String name, String label, List<String> items, int defItem,
			int x, int y, int w, int h, int barH, int itemH, int fg, int bg, int act) {
		ScrollableList l = cp5.addScrollableList(name).setPosition(x, y);

		if (items != null)
			l.addItems(items);

		if (barH > 0)
			l.setBarHeight(barH);
		if (itemH > 0)
			l.setItemHeight(itemH);

		if (defItem < 0)
			defItem = 0;
		l.setValue(defItem);

		l.setColorForeground(fg);
		l.setColorBackground(bg);
		l.setColorActive(act);

		if (x > 0 && y > 0)
			l.setSize(w, h);
		if (label != null)
			l.setLabel(label);

		return l;
	}

//Slider

	public Slider addSlider(ControlP5 cp5, String name, String label, int x, int y, float min, float max, float def) {
		return addSlider(cp5, name, label, x, y, 0, 0, min, max, def, SLIDER_COLOR_FG, SLIDER_COLOR_BG,
				SLIDER_COLOR_ACT);
	}

	public Slider addSlider(ControlP5 cp5, String name, String label, int x, int y, int h, int w, float min, float max,
			float def) {
		return addSlider(cp5, name, label, x, y, h, w, min, max, def, SLIDER_COLOR_FG, SLIDER_COLOR_BG,
				SLIDER_COLOR_ACT);
	}

	public Slider addSlider(ControlP5 cp5, String name, String label, int x, int y, int h, int w, float min, float max,
			float def, int fg, int bg, int act) {
		Slider s = cp5.addSlider(name).setCaptionLabel(label).setPosition(x, y).setRange(min, max).setValue(def);

		s.setColorForeground(fg);
		s.setColorBackground(bg);
		s.setColorActive(act);

		if (h > 0 && w >= 0)
			s.setSize(h, w);
		return s;
	}

	public ColorWheel addColorWheel(ControlP5 cp5, String name, int x, int y, int d) {
		ColorWheel colorWheel = cp5.addColorWheel(name, x, y, d);
		colorWheel.setPosition(x, y);
		return colorWheel;
	}

//Toggles
	public Toggle addToggle(ControlP5 cp5, String name, String label, int x, int y, int w, int h, int fg, int bg,
			int act) {
		Toggle t = cp5.addToggle(name).setPosition(x, y);

		t.setColorForeground(fg);
		t.setColorBackground(bg);
		t.setColorActive(act);

		if (x > 0 && y > 0)
			t.setSize(w, h);
		if (label != null)
			t.setLabel(label);

		return t;
	}

	public void settings() {
		size(930, 160);
	}

	static public void main(String[] passedArgs) {
		String[] appletArgs = new String[] { "com.serifpersia.pianoled.PianoLED" };
		if (passedArgs != null) {
			PApplet.main(concat(appletArgs, passedArgs));
		} else {
			PApplet.main(appletArgs);
		}
	}
}
