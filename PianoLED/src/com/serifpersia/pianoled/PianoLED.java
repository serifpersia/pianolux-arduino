package com.serifpersia.pianoled;

import processing.core.PApplet;

/* auto generated by Processing revision 1292 on 2023-03-30 */
import processing.core.*;
import processing.serial.*;
import javax.sound.midi.*;
import themidibus.*;
import static javax.swing.JOptionPane.*;
import java.util.*;
import java.util.regex.*;
import controlP5.*;
import java.io.ByteArrayOutputStream;
import java.io.InputStreamReader;
import javax.swing.JOptionPane;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.net.URL;
import java.net.URLConnection;
import java.io.File;
import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import javax.swing.SwingUtilities;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JProgressBar;
import org.json.JSONArray;
import org.json.JSONObject;

import javax.swing.JFileChooser;
import javax.swing.filechooser.FileFilter;
import javax.swing.JTextArea;
import javax.swing.JScrollPane;
import java.awt.Color;
import java.awt.Font;

import java.util.ArrayList;
import java.io.BufferedReader;

public class PianoLED extends PApplet {
	private UIHelper ui;
	private Arduino arduino;

	Sequencer sequencer;
	JFrame newWindowFrame;
	boolean midiPlay = false;
	PianoRoll pianoRoll;
	int PIANO_ROLL_HEIGHT = 960;
	int PIANO_ROLL_WIDTH = 600;
	final static int TOP_COLOR = 255;

	static public void main(String[] passedArgs) {
		String[] appletArgs = new String[] { "com.serifpersia.pianoled.PianoLED" };
		if (passedArgs != null) {
			PApplet.main(concat(appletArgs, passedArgs));
		} else {
			PApplet.main(appletArgs);
		}
	}

//Map function maps pitch first last note and number of leds
	public int mapMidiNoteToLED(int midiNote, int lowestNote, int highestNote, int stripLEDNumber, int outMin) {
		int outMax = outMin + stripLEDNumber - 1; // highest LED number
		int mappedLED = (midiNote - lowestNote) * (outMax - outMin) / (highestNote - lowestNote);
		return mappedLED + outMin;
	}

	public int mapMidiNoteToLEDFixed(int midiNote, int lowestNote, int highestNote, int stripLEDNumber, int outMin) {
		int outMax = outMin + stripLEDNumber - 1; // highest LED number
		int mappedLED = (midiNote - lowestNote) * (outMax - outMin) / (highestNote - lowestNote);

		if (midiNote >= 57) {
			mappedLED -= 1;
		}

		if (midiNote >= 93) {
			mappedLED -= 1;
		}
		return mappedLED + outMin;
	}

	int counter = 0;
	int lastNoteSelected, firstNoteSelected, numberselected, notePushed, noteOnVelocity;
	int leftMinPitch = 21;
	int leftMaxPitch;
	int rightMaxPitch = 108;
	boolean useFixedMapping = false;
	boolean openNewWindow = false;
	boolean BGColor = false, VelocityOn = false, RandomOn = false, SplitOn = false, GradientOn = false,
			SplashOn = false, AnimationOn = false, LearnMidiOn = false;
	List<String> m = Arrays.asList("Default", "Splash", "Random", "Gradient", "Velocity", "Split", "Animation",
			"Piano Roll");

// Create an ArrayList to hold the names of the MIDI devices
	ArrayList<String> midilist = new ArrayList<String>();
	ArrayList<String> midioutlist = new ArrayList<String>();

	String portName;
	String midiName; // midi input device
	String midiOutName; // midi output device
	String comlist[];
	String presetText;
	String os = System.getProperty("os.name").toLowerCase();
	String VersionTag;
	String VersionFile;
	String owner = "serifpersia";
	String repo = "pianoled-arduino";
	String fileName;
	String downloadUrl;
	String saveDir = System.getProperty("user.dir") + "/";
	String destinationFolderPath = System.getProperty("user.dir") + "/";
	String appPath = System.getProperty("user.dir");

	public String getDownloadUrl(JSONObject release, String fileName) {
		JSONArray assets = release.getJSONArray("assets");
		for (int i = 0; i < assets.length(); i++) {
			JSONObject asset = assets.getJSONObject(i);
			if (asset.getString("name").equals(fileName)) {
				return asset.getString("browser_download_url");
			}
		}
		return null;
	}

	public JSONObject getLatestRelease(String url) {
		try {
			// String authToken = ""; // replace with your PAT
			URL apiLink = new URL(url);
			URLConnection conn = apiLink.openConnection();
			conn.setRequestProperty("Accept", "application/vnd.github.v3+json");
			conn.setRequestProperty("User-Agent", "Java");
			// conn.setRequestProperty("Authorisation", "token " + authToken); // set the
			// authorisation header with your PAT
			BufferedInputStream in = new BufferedInputStream(conn.getInputStream());
			byte[] dataBuffer = new byte[1024];
			int bytesRead;
			StringBuilder responseBuilder = new StringBuilder();
			while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {
				responseBuilder.append(new String(dataBuffer, 0, bytesRead));
			}
			in.close();
			return new JSONObject(responseBuilder.toString());
		} catch (Exception e) {
			System.err.println("Error: " + e.getMessage());
			return null;
		}
	}

	File folder = new File(appPath);
	File[] listOfFiles = folder.listFiles();
	File versionFile = null;

	MidiBus myBusIn;
	MidiBus myBusOut;

	public void settings() {
		size(930, 160);
	}

	public void setup() {
		surface.setTitle("PianoLED");
		surface.setSize(960, 160);

		PImage icon = loadImage("images/PianoLED.png"); // replace with the name and extension of your icon file
		surface.setIcon(icon);

		ControlP5 cp5 = new ControlP5(this);
		ui = buildUI(this, cp5);

		ui.getController("modelist").setValue(0);

		Refresh();

		numberselected = 176;
		firstNoteSelected = 21;
		lastNoteSelected = 108;

		setSystemFileDownload();

		checkLocalVersion();
	}

	public void setSystemFileDownload() {
	}

	public void checkLocalVersion() {

		for (int i = 0; i < listOfFiles.length; i++) {
			if (listOfFiles[i].isFile()) {
				String fileName = listOfFiles[i].getName();
				if (fileName.matches(".*v\\d+\\.\\d+.*")) {
					VersionTag = fileName.replaceAll(".*(v\\d+\\.\\d+).*", "$1");
					versionFile = listOfFiles[i];
					break;
				}
			}
		}
		System.out.println("VersionTag: " + VersionTag);
	}

//button update
	public void checkForUpdates() {
		// Show confirmation dialog to check for updates
		int confirm = JOptionPane.showOptionDialog(null, "Do you want to check for updates?", "Update Checker",
				JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, null, null);

		if (confirm == JOptionPane.YES_OPTION) {
			String releaseUrl = String.format("https://api.github.com/repos/%s/%s/releases/latest", owner, repo);
			JSONObject latestRelease = getLatestRelease(releaseUrl);

			if (latestRelease == null) {
				JOptionPane.showMessageDialog(null, "Unable to retrieve latest release information.", "Update",
						JOptionPane.INFORMATION_MESSAGE);
				return;
			}

			// Compare the latest release tag with the local version tag
			if (VersionTag != null && VersionTag.equals(latestRelease.getString("tag_name"))) {
				JOptionPane.showMessageDialog(null, "You already have the latest version.", "Update",
						JOptionPane.INFORMATION_MESSAGE);
				return;
			}

			if (VersionTag == null) {
				String message = "Unable to retrieve local app information";
				JOptionPane.showMessageDialog(null, message, "Update", JOptionPane.INFORMATION_MESSAGE);
				return;
			}

			// Show confirmation dialog to download the latest release
			confirm = JOptionPane.showOptionDialog(null, "A new update is available. Do you want to download it?",
					"Update Checker", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, null, null);

			if (confirm == JOptionPane.YES_OPTION) {
				// Download and extract the latest release
				String downloadUrl, fileName;
				if (os.contains("win")) {
					fileName = "PianoLED-windows-amd64.zip";
					println("File to download: " + fileName);
				} else {
					fileName = "PianoLED-linux-amd64.zip";
				}
				downloadUrl = getDownloadUrl(latestRelease, fileName);

				try {
					// Download the file with a progress bar
					URL url = new URL(downloadUrl);
					URLConnection conn = url.openConnection();
					conn.connect();
					int contentLength = conn.getContentLength();
					BufferedInputStream in = new BufferedInputStream(conn.getInputStream());
					FileOutputStream out = new FileOutputStream(saveDir + fileName);
					BufferedOutputStream bout = new BufferedOutputStream(out, 1024);
					byte[] data = new byte[1024];
					int x = 0;
					int bytesRead = 0;

					// Create progress bar
					JProgressBar progressBar = new JProgressBar();
					progressBar.setStringPainted(true);

					// Create dialog to show progress bar
					JDialog dialog = new JDialog();
					dialog.add(progressBar);
					dialog.setTitle("Downloading update...");
					dialog.setSize(300, 75);
					dialog.setLocationRelativeTo(null);
					dialog.setVisible(true);

					while ((bytesRead = in.read(data, 0, 1024)) >= 0) {
						bout.write(data, 0, bytesRead);
						x += bytesRead;
						int percentCompleted = (int) ((x / (float) contentLength) * 100);

						// Update progress bar
						SwingUtilities.invokeLater(new Runnable() {
							public void run() {
								progressBar.setValue(percentCompleted);
							}
						});
					}
					bout.close();
					in.close();
					extractZipFile(saveDir + fileName, destinationFolderPath);
					dialog.dispose(); // Close progress bar dialog
					String restartMessage = "The app has been updated to " + latestRelease.getString("tag_name")
							+ ". Please restart PianoLED.";
					JOptionPane.showMessageDialog(null, restartMessage, "Update", JOptionPane.INFORMATION_MESSAGE);
					deleteOldFile();
				} catch (Exception e) {
				}
			}
		}
	}

	public void deleteOldFile() {
		if (versionFile != null) { // check the flag value before deleting the version file
			boolean deleted = versionFile.delete();
			if (deleted) {
				System.out.println("Deleted version file: " + versionFile.getName());
				exit();
			} else {
				System.out.println("Failed to delete version file: " + versionFile.getName());
			}
		}
	}

	public void extractZipFile(String zipFilePath, String destinationFolderPath) {
		try {
			ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(zipFilePath));
			ZipEntry zipEntry = zipInputStream.getNextEntry();
			byte[] buffer = new byte[1024];

			while (zipEntry != null) {
				String fileName = zipEntry.getName();
				File newFile = new File(destinationFolderPath + fileName);
				System.out.println("Extracting file: " + newFile.getAbsolutePath());

				if (zipEntry.isDirectory()) {
					// Create the directory
					newFile.mkdirs();
				} else {
					// Create all non-existing parent directories
					new File(newFile.getParent()).mkdirs();

					// Write the file contents
					FileOutputStream fos = new FileOutputStream(newFile);
					int len;
					while ((len = zipInputStream.read(buffer)) > 0) {
						fos.write(buffer, 0, len);
					}
					fos.close();
				}

				zipEntry = zipInputStream.getNextEntry();
			}

			zipInputStream.closeEntry();
			zipInputStream.close();

			System.out.println("Zip file extracted to: " + destinationFolderPath);

			// Delete the zip file
			File zipFile = new File(zipFilePath);
			if (zipFile.delete()) {
				System.out.println("Zip file deleted successfully");
			} else {
				System.err.println("Failed to delete zip file");
			}
		} catch (IOException e) {
			System.err.println("Error extracting zip file: " + e.getMessage());
		}
	}

	public void midi(int n) {
		try {
			// Set the midiName variable to the name of the selected MIDI device
			midiName = midilist.get(n);
			println("Selected midi input device: " + midiName);
		} catch (Exception NoDevicesAvailable) {
			println("No devices Available. plugin devices into your computer first!");
		}
	}

	public void midiout(int n) {
		try {
			// Set the midiName variable to the name of the selected MIDI device
			midiOutName = midioutlist.get(n);
			println("Selected midi output device: " + midiOutName);
		} catch (Exception NoDevicesAvailable) {
			println("No devices Available. plugin devices into your computer first!");
		}
	}

	public void noteOn(int channel, int pitch, int velocity) {

		if (useFixedMapping) {
			notePushed = mapMidiNoteToLEDFixed(pitch, firstNoteSelected, lastNoteSelected, numberselected, 1);
		} else {
			notePushed = mapMidiNoteToLED(pitch, firstNoteSelected, lastNoteSelected, numberselected, 1);
		}
		Keys[pitch - 21][0] = 1;
		Keys[pitch - 21][1] = 1;
		try {
			ByteArrayOutputStream message = null;

			if (!AnimationOn) {
				if (RandomOn) {
					message = arduino.commandSetColor((int) random(1, 250), (int) random(1, 250), (int) random(1, 250),
							notePushed);
				} else if (VelocityOn) {
					message = arduino.commandVelocity(velocity, notePushed, Red, Green, Blue);
				} else if (SplitOn) {
					if (pitch >= leftMinPitch && pitch <= leftMaxPitch - 1) {
						println("Left Side Color");
						message = arduino.commandSetColor(splitLeftRed, splitLeftGreen, splitLeftBlue, notePushed);
					} else if (pitch > leftMaxPitch - 1 && pitch <= rightMaxPitch) {
						println("Right Side Color");
						message = arduino.commandSetColor(splitRightRed, splitRightGreen, splitRightBlue, notePushed);
					}
				} else if (GradientOn) {
					int numSteps = numberselected - 1;
					int step = notePushed - 1;
					float ratio = (float) step / (float) numSteps;

					int startColor = color(LeftSideGRed, LeftSideGGreen, LeftSideGBlue);
					int endColor = color(RightSideGRed, RightSideGGreen, RightSideGBlue);

					int currentColor;
					if (MiddleSideGRed == 0 && MiddleSideGGreen == 0 && MiddleSideGBlue == 0) {
						currentColor = lerpColor(startColor, endColor, ratio);
					} else {
						int middleColor = color(MiddleSideGRed, MiddleSideGGreen, MiddleSideGBlue);
						float leftRatio = ratio * 0.5f;
						float rightRatio = (ratio - 0.5f) * 2f;

						int leftColor = lerpColor(startColor, middleColor, leftRatio);
						int rightColor = lerpColor(middleColor, endColor, rightRatio);

						currentColor = lerpColor(leftColor, rightColor, ratio);
					}

					int red = (int) red(currentColor);
					int green = (int) green(currentColor);
					int blue = (int) blue(currentColor);

					message = arduino.commandSetColor(red, green, blue, notePushed);
				} else if (SplashOn) {
					message = arduino.commandSplash(velocity, notePushed, getSplashColor());
				} else {
					message = arduino.commandSetColor(Red, Green, Blue, notePushed);
				}

				if (message != null) {
					arduino.sendToArduino(message);
				}
			}
		} catch (Exception e) {
			showMessageDialog(null, "Error sending command: " + e);
			println(e);
		}
	}

	public static void printMessage(ByteArrayOutputStream msg) {
		byte[] bytes = msg.toByteArray();
		print("Message:");
		for (byte b : bytes) {
			int unsignedValue = b & 0xFF;
			print(unsignedValue + " ");
		}
		println();
	}

	public void noteOff(int channel, int pitch, int velocity) {
		if (useFixedMapping) {
			notePushed = mapMidiNoteToLEDFixed(pitch, firstNoteSelected, lastNoteSelected, numberselected, 1);
		} else {
			notePushed = mapMidiNoteToLED(pitch, firstNoteSelected, lastNoteSelected, numberselected, 1);
		}
		Keys[pitch - 21][0] = 0;
		Keys[pitch - 21][1] = 0;
		try {
			if (!AnimationOn) {
				arduino.sendCommandKeyOff(notePushed);
			}
		} catch (Exception e) {
		}
	}

	public void comlist(int n) {
		portName = Serial.list()[n];
		println("Selected serial device: " + portName);
	}

	public void disableAllModes() {
		RandomOn = false;
		VelocityOn = false;
		AnimationOn = false;
		SplitOn = false;
		GradientOn = false;
		SplashOn = false;
	}

	public void colorlist(int n) {
		int selectedColor = presetColors[n];

		Red = round(red(selectedColor));
		Green = round(green(selectedColor));
		Blue = round(blue(selectedColor));

		ui.get(ColorWheel.class, "Color").setRGB(selectedColor);

		println("Selected color: " + colorNames.get(n));
		println("RGB values: " + red(selectedColor) + ", " + green(selectedColor) + ", " + blue(selectedColor));
	}

	public void animationlist(int n) {
		String selectedAnimation = animationNames.get(n);
		println("Selected Animation: " + selectedAnimation);
		if (n < 0 || n > 6) {
			println("Invalid animation selection.");
			return;
		}
		if (arduino != null)
			arduino.sendCommandAnimation(n);
	}

	public void BGColor(boolean on) {
		println("Set BG: " + on);
		int BG_HUE = 100;
		int BG_SATURATION = 0;
		int BG_BRIGHTNESS = 20;

		if (on) {
			if( arduino != null )
				arduino.sendCommandSetBG(BG_HUE, BG_SATURATION, BG_BRIGHTNESS);
			showBGControls();
		} else {
			arduino.sendCommandSetBG(0, 0, 0);
			hideBGControls();
		}
	}

	public void stripDirection(boolean on) {
		arduino.sendCommandStripDirection(on ? 1 : 0, numberselected);
	}

	public void TeacherFollowKey(boolean on) {
		pianoRoll.setFollowKey(on);
	}

	public void Fix() {
		useFixedMapping = !useFixedMapping; // toggle the state
	}

	public void setBG() {
		int red = Red; // Red value from 0-255
		int green = Green; // Green value from 0-255
		int blue = Blue; // Blue value from 0-255

		float[] hsbValues = java.awt.Color.RGBtoHSB(red, green, blue, null);
		int hue = (int) (hsbValues[0] * 255);
		int saturation = (int) (hsbValues[1] * 255);
		int brightness = 20;

		if (arduino != null)
			arduino.sendCommandSetBG(hue, saturation, brightness);
	}

	public void modelist(int n) {
		if (arduino != null)
			arduino.sendCommandBlackOut();

		switch (n) {
		case 0: // Default
			disableAllModes();
			hideAllControls();
			showDefaultControls();
			setDefaultDefaults(255, 127);
			break;
		case 1: // Splash
			disableAllModes();
			hideAllControls();
			showSplashControls();
			setSplashDefaults(11, 110, 0, 127);
			SplashOn = true;
			break;
		case 2: // Random
			disableAllModes();
			hideAllControls();
			setDefaultDefaults(255, 127);
			showRandomControls();
			RandomOn = true;
			break;
		case 3: // Gradient
			disableAllModes();
			hideAllControls();
			setDefaultDefaults(255, 127);
			showGradientControls();
			GradientOn = true;
			break;
		case 4: // Velocity
			disableAllModes();
			hideAllControls();
			setDefaultDefaults(255, 127);
			showVelocityControls();
			VelocityOn = true;
			break;
		case 5: // Split
			disableAllModes();
			hideAllControls();
			setDefaultDefaults(255, 127);
			showSplitControls();
			SplitOn = true;
			break;
		case 6: // Animation
			disableAllModes();
			hideAllControls();
			showAnimationControls();
			setAnimationDefaults(0, 127);
			AnimationOn = true;
			break;
		case 7: // PianoRoll
			disableAllModes();
			hideAllControls();
			showPianoRollControls();
			LearnMidiOn = true;
			break;
		}
		println("Selected mode: " + m.get(n));
	}

	public void Open() {

		if (ui.getController("Open").getCaptionLabel().getText().equals("Open")) {
			try {
				myBusIn = new MidiBus(this, midiName, 0);
				myBusOut = new MidiBus(this, midiOutName, 0);
				println("Midi Input Port Open: " + midiName);
				arduino = new Arduino(this, portName, 115200);
				println("Serial Port Open : " + portName);
				ui.getController("Open").getCaptionLabel().setText("Close");
				ui.getController("Open").setColorBackground(color(0, 255, 0));

				arduino.sendCommandBlackOut();
				Toggle bg = (Toggle) ui.getController("BGColor");
				BGColor(bg.getState());
				int fadeRate = (int) ui.getController("FadeOnVal").getValue();
				arduino.sendCommandFadeRate(fadeRate);
				Toggle sd = (Toggle) ui.getController("stripDirection");
				stripDirection(sd.getState());
			} catch (Exception e) {
				println("Error opening serial port: " + e.getMessage());
			}
		} else {
			if (arduino != null) {
				myBusIn.dispose();
				myBusOut.dispose();
				arduino.sendCommandBlackOut();
				BGColor(false);
				arduino.stop();
				println("Device closed: " + portName);
				println("Device closed: " + midiName);
				ui.getController("Open").getCaptionLabel().setText("Open");
				ui.getController("Open").setColorBackground(color(0, 0, 0));
			}
		}
	}

//was float
	public void FadeOnVal(int value) {
		if (arduino != null)
			arduino.sendCommandFadeRate((int) value);
	}

//was float
	public void Brightness(int value) {
		if (arduino != null)
			arduino.sendCommandBrightness((int) value);
	}

	public void Refresh() {

		if (os.contains("win")) {
			findPortNameOnWindows("Arduino");
		} else {
			findPortNameOnLinux("ttyACM");
		}
		refreshComList();
		refreshMidiList();
	}

	public void findPortNameOnWindows(String deviceName) {
		String[] cmd = { "cmd", "/c",
				"wmic path Win32_PnPEntity where \"Caption like '%(COM%)'\" get Caption /format:table" };
		portName = null;
		try {
			Process p = Runtime.getRuntime().exec(cmd);
			BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
			String line;
			while ((line = reader.readLine()) != null) {
				if (line.contains(deviceName)) {
					String[] tokens = line.split("\\s+");
					portName = tokens[tokens.length - 1].replaceAll("[()]", "");
					println("Device found: " + line);
					break;
				}
			}
			reader.close();
		} catch (IOException e) {
			println("Error: " + e.getMessage());
		}
	}

	public void findPortNameOnLinux(String deviceName) {
		String[] cmd = { "sh", "-c", "dmesg | grep " + deviceName };
		portName = null;
		Pattern pattern = Pattern.compile(deviceName + "(\\d+)");
		try {
			Process p = Runtime.getRuntime().exec(cmd);
			BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
			String line;
			while ((line = reader.readLine()) != null) {
				Matcher matcher = pattern.matcher(line);
				if (matcher.find()) {
					portName = "/dev/" + matcher.group(0);
					println("Device found: " + portName);
					break;
				}
			}
			reader.close();
		} catch (IOException e) {
			println("Error: " + e.getMessage());
		}
	}

	public void refreshComList() {
		comlist = Serial.list();
		ui.get(ScrollableList.class, "comlist").clear();
		ui.get(ScrollableList.class, "comlist").addItems(comlist);

		int portIndex = Arrays.asList(comlist).indexOf(portName);
		if (portIndex >= 0) {
			ui.get(ScrollableList.class, "comlist").setValue(portIndex);
		}
	}

	public void refreshMidiList() {
		midilist.clear();
		midioutlist.clear();

		MidiDevice.Info[] info_midiIn = MidiSystem.getMidiDeviceInfo();
		for (MidiDevice.Info info : info_midiIn) {
			try {
				MidiDevice device = MidiSystem.getMidiDevice(info);
				if (device.getMaxTransmitters() != 0) {
					midilist.add(info.getName());
				}
				device.close();
			} catch (MidiUnavailableException e) {
				// Handle the exception
			}
		}

		MidiDevice.Info[] info_midiOut = MidiSystem.getMidiDeviceInfo();
		for (MidiDevice.Info info : info_midiOut) {
			try {
				MidiDevice device = MidiSystem.getMidiDevice(info);
				if (device.getMaxReceivers() != 0) {
					midioutlist.add(info.getName());
				}
				device.close();
			} catch (MidiUnavailableException e) {
				// Handle the exception
			}
		}
		ui.get(ScrollableList.class, "midi").clear();
		ui.get(ScrollableList.class, "midi").addItems(midilist);
		ui.get(ScrollableList.class, "midi").setValue(findDefaultMidi(midilist, Arrays.asList("piano", "midi")));

		ui.get(ScrollableList.class, "midiout").clear();
		ui.get(ScrollableList.class, "midiout").addItems(midioutlist);
		ui.get(ScrollableList.class, "midiout").setValue(findDefaultMidi(midioutlist, Arrays.asList("piano", "midi")));
	}

	public int findDefaultMidi(List<String> values, List<String> keywords) {
		int index = 0;
		for (String value : values) {
			for (String keyword : keywords) {
				if (value.toLowerCase().contains(keyword)) {
					return index;
				}
			}
			index++;
		}
		return 0;
	}

	public void CheckForUpdate() {
		checkForUpdates();
	}

//Instruction Buttton
	public void Instructions() {
		if (newWindowFrame == null) {
			// create a new window frame
			newWindowFrame = new JFrame("Instructions");
			newWindowFrame.setSize(600, 600);
			newWindowFrame.setLocationRelativeTo(null);
			newWindowFrame.setResizable(false);
			// create a JTextArea object and add it to a JScrollPane
			JTextArea textArea = new JTextArea("Short Instructions for PianoLED\n\n"
					+ "Your Arduino and MIDI devices should be auto selected all you have to do is click open\n"
					+ "to start using PianoLED.\n"
					+ "\nMake sure you upload the ArduinoPianoLED.ino file before using PianoLED app.\n"
					+ "\nFixLED: Fixes the leds position if you your strip is soldered together and not a single strip.\n"
					+ "\nReverse: Reverses the led strip directions useful if the default is not ideal for your setup.\n"
					+ "\nBG: Turns on background color for all modes,color and brightness adjustable.\n"
					+ "\nAvailable modes:\n"
					+ "- Default: Single led based control,fade rate, brightness & color can be adjusted\n"
					+ " with ui sliders,color wheel and premade color presets.\n"
					+ "- Splash: Multiple leds light up,fade rate, brightness,tail length & color can be adjusted.\n"
					+ "- Random: Single led based control, this time random colors only, fade & brightness still\n"
					+ "adjustable.\n"
					+ "- Gradient: Three new buttons Set LG,MG,RG each setting color for corresponding sides.\n"
					+ "Make sure you select color & set that as side color with LG,MG.RG buttons.If middle side\n"
					+ "color is not set the gradient will work in two sides color mode.\n"
					+ "\n- Velocity: Based on how hard the user is playing the notes,the single led will light up\n"
					+ "differently.\n"
					+ "- Split: Splits the led strip into two sides. The split point can be set by clicking on the key\n"
					+ "in the piano UI.\n"
					+ "\nMake sure you select color first,set the sides color with Set L, R & chose your split point.\n"
					+ "\nAnimation: Led strip lights up depending on what animation preset you selected.\n"
					+ "\nThat's all if you need more help check out the discord server for help & updates:\n"
					+ "discord: https://discord.com/invite/S6xmuX4Hx5\n"
					+ "\nPianoLED Â© 2023 by serifpersia. All rights reserved\n");
			textArea.setBackground(Color.BLACK);
			textArea.setForeground(Color.WHITE);
			textArea.setFont(new Font("Arial", Font.PLAIN, 14));
			JScrollPane scrollPane = new JScrollPane(textArea);
			newWindowFrame.add(scrollPane);
			newWindowFrame.addWindowListener(new java.awt.event.WindowAdapter() {
				public void windowClosing(java.awt.event.WindowEvent e) {
					newWindowFrame.dispose();
					newWindowFrame = null;
				}
			});
			newWindowFrame.setVisible(true);
		}
	}

	public void setLeftSide() {
		splitLeftRed = (Red);
		splitLeftGreen = (Green);
		splitLeftBlue = (Blue);
	}

	public void setRightSide() {
		splitRightRed = (Red);
		splitRightGreen = (Green);
		splitRightBlue = (Blue);
	}

	public void setLeftSideG() {
		LeftSideGRed = (Red);
		LeftSideGGreen = (Green);
		LeftSideGBlue = (Blue);
	}

	public void setMiddleSideG() {
		MiddleSideGRed = (Red);
		MiddleSideGGreen = (Green);
		MiddleSideGBlue = (Blue);
	}

	public void setRightSideG() {
		RightSideGRed = (Red);
		RightSideGGreen = (Green);
		RightSideGBlue = (Blue);
	}

	public void mousePressed() {
		for (int i = 0; i < whiteKeys.length; i++) {
			// Check if the mouse click was inside a white key
			if (mouseX > i * 15 + 15 && mouseX < (i + 1) * 15 + 15 && mouseY > 64 && mouseY < 134) {
				leftMaxPitch = whiteKeyPitches[i];
				Keys[whiteKeys[i]][0] = 1;
				println("Left Max Pitch: " + leftMaxPitch);
			}
		}
	}

	public void mouseReleased() {
		for (int i = 0; i < whiteKeys.length; i++) {
			// Check if the mouse click was inside a white key
			if (mouseX > i * 15 + 15 && mouseX < (i + 1) * 15 + 15 && mouseY > 64 && mouseY < 134) {
				// Change the color of the clicked key back to white
				Keys[whiteKeys[i]][0] = 0;
			}
		}
	}

	public void keyPressed() {

		if (key == 'l') {
			PianoRollLoadMidi();
		} else if (key == ' ') {
			PianoRollPlayPause();
		} else if (key == CODED) {
			if (keyCode == UP) {
				PianoRollRewind();
			} else if (keyCode == LEFT) {
				PianoRollBackwardFragment();
			} else if (keyCode == RIGHT) {
				PianoRollForwardFragment();
			}
		}
	}

	public void PianoRollPlayPause() {
		if (pianoRoll != null)
			pianoRoll.pause();
		Button button = ui.get(Button.class, "PianoRollPlayPause");
		if (pianoRoll.isPaused()) {
			button.getCaptionLabel().setText(">");
			button.setColorBackground(Color.BLUE.getRGB());
		} else {
			button.getCaptionLabel().setText("||");
			button.setColorBackground(Color.GREEN.getRGB());
		}
	}

	public void PianoRollRewind() {
		if (pianoRoll != null)
			pianoRoll.rewind();
	}

	public void PianoRollForwardFragment() {
		if (pianoRoll != null)
			pianoRoll.rewind(PianoRoll.REWIND_FRAGMENT_SEC);
	}

	public void PianoRollBackwardFragment() {
		if (pianoRoll != null)
			pianoRoll.rewind(-PianoRoll.REWIND_FRAGMENT_SEC);
	}

	public void PianoRollLoadMidi() {
		// Use a file chooser dialog box to get the MIDI file to play
		JFileChooser chooser = new JFileChooser();
		chooser.setCurrentDirectory(new File("."));

		// Add a file filter to only allow MIDI files
		FileFilter filter = new FileFilter() {
			public boolean accept(File file) {
				String filename = file.getName().toLowerCase();
				return filename.endsWith(".mid") || filename.endsWith(".midi") || file.isDirectory();
			}

			public String getDescription() {
				return "MIDI files (*.mid, *.midi)";
			}
		};
		chooser.setFileFilter(filter);

		int result = chooser.showOpenDialog(null);
		if (result == JFileChooser.APPROVE_OPTION) {
			File midiFile = chooser.getSelectedFile();

			try {

				// Get the selected MIDI output device
				int midiOutIndex = (int) ui.get(ScrollableList.class, "midiout").getValue();
				MidiDevice.Info[] midiOutDeviceInfo = MidiSystem.getMidiDeviceInfo();
				MidiDevice midiOutDevice = MidiSystem.getMidiDevice(midiOutDeviceInfo[midiOutIndex]);
				surface.setSize(PIANO_ROLL_HEIGHT, PIANO_ROLL_WIDTH);
				pianoRoll = new PianoRoll(this, midiFile, midiOutDevice);
			} catch (Exception ex) {
				ex.printStackTrace();
			}
		}
	}

	public void dispose() {
		try {
			arduino.sendCommandBlackOut();
			arduino.sendCommandSetBG(0, 0, 0);
			if (myBusIn != null && myBusOut != null) {
				myBusIn.dispose();
				myBusOut.dispose();
			}
			if (arduino != null) {
				arduino.stop();
			}
		} catch (Exception e) {
			println("Error while exiting: " + e);
		}
		exit();
	}

	public void setAnimationDefaults(int fadeRate, int brightness) {
		ui.getController("FadeOnVal").setValue(fadeRate);
		ui.getController("Brightness").setValue(brightness);
		ui.getController("Brightness").setPosition(EFFECT_CONTROLS_X - 15, 65);
	}

	public void setDefaultDefaults(int fadeRate, int brightness) {
		ui.getController("FadeOnVal").setValue(fadeRate);
		ui.getController("Brightness").setValue(brightness);
		ui.getController("Brightness").setPosition(EFFECT_CONTROLS_X - 4, 65);
	}

	public void splashMaxLength(float value) {
		if (arduino != null)
			arduino.sendCommandSplashMaxLength((int) value);
	}

	public void setSplashDefaults(int splashLen, int fadeRate, int splashColor, int brightness) {
		ui.getController("splashMaxLength").setValue(splashLen);
		ui.getController("FadeOnVal").setValue(fadeRate);
		ui.get(ScrollableList.class, "splashColor").setValue(splashColor);
		ui.getController("Brightness").setValue(brightness);
	}

	public void splashColor(int n) {
		int first = 0;
		int last = splashColorNames.size() - 1;
		if (n > first && n < last) {
			ui.get(ColorWheel.class, "Color").setRGB(presetColors[n - 1]);
		}
	}

	public int getSplashColor() {
		int n = (int) ui.get(ScrollableList.class, "splashColor").getValue();
		int first = 0;
		int splashColor;
		int last = splashColorNames.size() - 1;
		if (n == first) {
			// Full Spectrum mode
			splashColor = color(0, 0, 0);
			println("Selected color: Full Spectrum");
		} else if (n > first && n < last) {
			// Preset color mode
			splashColor = presetColors[n - 1];
			println("Selected color: " + colorNames.get(n - 1));

		} else if (n == last) {
			// Manual
			splashColor = ui.get(ColorWheel.class, "Color").getRGB();
		} else {
			// Invalid color mode
			println("Invalid color selection: " + n);
			return 0;
		}
		return splashColor;
	}

//	ControlP5 cp5;

	int MIN_FADE_RATE = 0;
	int MAX_FADE_RATE = 255;
	int DEFAULT_FADE_RATE = 255;

	int MIN_BRIGHT = 0;
	int MAX_BRIGHT = 255;
	int DEF_BRIGHT = 127;

	int MIN_COLOR = 0;
	int MAX_COLOR = 255;
	int DEF_COLOR = MAX_COLOR;
	int EFFECT_CONTROLS_X = 811;

	int Red = MAX_COLOR, Green = MAX_COLOR, Blue = MAX_COLOR, Brightness = MAX_COLOR, FadeOnVal = MAX_COLOR,
			velRedL = MAX_COLOR, velGreenL = MAX_COLOR, velBlueL = MAX_COLOR, velRedLM = MAX_COLOR,
			velGreenLM = MAX_COLOR, velBlueLM = MAX_COLOR, velRedM = MAX_COLOR, velGreenM = MAX_COLOR,
			velBlueM = MAX_COLOR, velRedH = MAX_COLOR, velGreenH = MAX_COLOR, velBlueH = MAX_COLOR,
			splitLeftRed = MAX_COLOR, splitLeftGreen = MAX_COLOR, splitLeftBlue = MAX_COLOR, splitRightRed = MAX_COLOR,
			splitRightGreen = MAX_COLOR, splitRightBlue = MAX_COLOR, LeftSideGRed = 0, LeftSideGGreen = 0,
			LeftSideGBlue = 0, RightSideGRed = 0, RightSideGGreen = 0, RightSideGBlue = 0, MiddleSideGRed = 0,
			MiddleSideGGreen = 0, MiddleSideGBlue = 0;

	int splashRed = 0;
	int splashGreen = 0;
	int splashBlue = 0;

	int[] presetColors = { color(255, 0, 0), // Red
			color(0, 255, 0), // Green
			color(0, 0, 255), // Blue
			color(255, 255, 0), // Yellow
			color(255, 128, 0), // Orange
			color(128, 0, 255), // Purple
			color(255, 0, 255), // Pink
			color(0, 255, 255), // Teal
			color(128, 255, 0), // Lime
			color(0, 255, 128), // Cyan
			color(255, 0, 128), // Magenta
			color(255, 128, 128), // Peach
			color(192, 128, 255), // Lavender
			color(128, 192, 192), // Turquoise
			color(255, 215, 0) // Gold
	};

	List<String> colorNames = Arrays.asList("Red", "Green", "Blue", "Yellow", "Orange", "Purple", "Pink", "Teal",
			"Lime", "Cyan", "Magenta", "Peach", "Lavender", "Turquoise", "Gold");
	List<String> splashColorNames = Arrays.asList("Full Spectrum", "Red", "Green", "Blue", "Yellow", "Orange", "Purple",
			"Pink", "Teal", "Lime", "Cyan", "Magenta", "Peach", "Lavender", "Turquoise", "Gold", "Manual");
	List<String> animationNames = Arrays.asList("RainbowColors", "RainbowStripeColor", "OceanColors", "CloudColors",
			"LavaColors", "ForestColors", "PartyColors");

	public UIHelper buildUI(PianoLED pianoLED, ControlP5 cp5) {

		ui = new UIHelper(pianoLED, cp5);

		ui.addToggle("BGColor2", " BG", 90, 25, 15, 15, Color.RED, Color.WHITE, Color.GREEN);

		ui.addSlider("Brightness", "  B", EFFECT_CONTROLS_X - 4, 65, 10, 69, MIN_BRIGHT, MAX_BRIGHT, DEF_BRIGHT,
				Color.BLUE, Color.BLACK, Color.RED);

		ui.addSlider("FadeOnVal", "  F", EFFECT_CONTROLS_X - 15, 65, 10, 69, MIN_FADE_RATE, MAX_FADE_RATE,
				DEFAULT_FADE_RATE, Color.GREEN, Color.BLACK, Color.RED);

		ui.addButton("CheckForUpdate", "Update", 620, 20, 45, 25);

		ui.addButton("setLeftSideG", "Set LG", 705, 140, 30, 15).hide();
		ui.addButton("setMiddleSideG", "Set MG", 735, 140, 30, 15).hide();
		ui.addButton("setRightSideG", "Set RG", 765, 140, 30, 15).hide();

		ui.addButton("setLeftSide", "Set L", 735, 140, 30, 15).hide();
		ui.addButton("setRightSide", "Set R", 765, 140, 30, 15).hide();

		ui.addButton("setBG", "Set BG", 670, 26, 30, 15).hide();

		ui.addButton("Open", null, 725, 45, 50, 15);
		ui.addButton("Refresh", null, 775, 45, 50, 15);

		ui.addColorWheel("Color", EFFECT_CONTROLS_X + 15, 45, 100);

		addAnimationControls();

		ui.addButton("leftArrow", "<", 380, 25, 30, 15, null, Color.BLUE, null);
		ui.addButton("rightArrow", ">", 415, 25, 30, 15, null, Color.BLUE, null);

		// addButton(cp5, "AdvanceUser", null, 15, 15, 60, 15);

		int SPLASH_CONTROL_X = EFFECT_CONTROLS_X + 6;
		int SPLASH_CONTROL_Y = 60;
		addSplashControls(SPLASH_CONTROL_X, SPLASH_CONTROL_Y);
		addPianoRollControls(EFFECT_CONTROLS_X + 10, 30);
		ui.addButton("Instructions", null, 15, 15, 60, 15);

		ui.addToggle("BGColor", " BG", 700, 25, 15, 15, Color.RED, Color.WHITE, Color.GREEN);
		ui.addToggle("stripDirection", "Reverse", 425, 42, 10, 8, Color.RED, Color.WHITE, Color.GREEN).getCaptionLabel()
				.alignX(ControlP5.CENTER);
		ui.addToggle("Fix", "Fix LED", 390, 42, 10, 8, Color.RED, Color.WHITE, Color.GREEN).getCaptionLabel()
				.alignX(ControlP5.CENTER);

		ui.addScrollableList("comlist", "Arduino Port", null, -1, 725, 15, 100, 110, 15, 15).close();
		ui.addScrollableList("midi", "Midi Device", null, -1, 725, 30, 100, 110, 15, 15).close();
		ui.addScrollableList("colorlist", "Color Preset", colorNames, 0, EFFECT_CONTROLS_X + 15, 30, 100, 100, 15, 15);
		ui.addScrollableList("modelist", "Mode", m, 0, EFFECT_CONTROLS_X + 15, 15, 100, 100, 15, 15).bringToFront();

		return ui;
	}

	public void addPianoRollControls(int origX, int origY) {
		int x = origX;
		int y = origY;
		int h = 25;
		int w = 25;
		PFont font = createFont("Arial", 12);

		ui.addScrollableList("midiout", "Midi Output Device", null, -1, EFFECT_CONTROLS_X + 15, y, 100, 110, 15, 15);
		y += 25;
		ui.addButton("PianoRollLoadMidi", "Load Midi File", EFFECT_CONTROLS_X + 15, y, 100, 15).hide();
		y += 25;
		ui.addButton("PianoRollRewind", "|<<", x, y, h, w, Color.RED, Color.BLUE, Color.GREEN).hide().getCaptionLabel()
				.setFont(font);
		x += w + 2;
		ui.addButton("PianoRollBackwardFragment", "-" + PianoRoll.REWIND_FRAGMENT_SEC, x, y, h, w, Color.RED,
				Color.BLUE, Color.GREEN).hide().getCaptionLabel().setFont(font);
		x += w + 2;
		ui.addButton("PianoRollPlayPause", ">", x, y, h, w, Color.RED, Color.BLUE, Color.GREEN).hide().getCaptionLabel()
				.setFont(font);
		x += w + 2;
		ui.addButton("PianoRollForwardFragment", "+" + PianoRoll.REWIND_FRAGMENT_SEC, x, y, h, w, Color.RED, Color.BLUE,
				Color.GREEN).hide().getCaptionLabel().setFont(font);
		x = origX;
		y += h + 5;
		// addToggle(cp5, "PianoRollFollowKey", "Teacher Mode", x, y, 15, 15, RED,
		// WHITE, GREEN).hide();

		ui.getController("midiout").bringToFront();
	}

	public void addSplashControls(int x, int y) {
		int SPLASH_MIN_LEN = 5;
		int SPLASH_MAX_LEN = 15;
		int SPLASH_DEFAULT_LEN = 8;

		int SPLASH_MIN_TAIL_FADE = 1;
		int SPLASH_MAX_TAIL_FADE = 50;
		int SPLASH_DAFAULT_TAIL_FADE = 15;

		int SPLASH_MIN_VELO_BRI = 5;
		int SPLASH_MAX_VELO_BRI = 15;
		int SPLASH_DAFAULT_VELO_BRI = 10;

		int SPLASH_MIN_VELO_SPEED = 5;
		int SPLASH_MAX_VELO_SPEED = 15;
		int SPLASH_DAFAULT_VELO_SPEED = 10;

		int SPLASH_CONTROL_Y_STEP = 13;

		ui.addSlider("splashMaxLength", "  L", EFFECT_CONTROLS_X + 7, 65, 10, 69, SPLASH_MIN_LEN, SPLASH_MAX_LEN,
				SPLASH_DEFAULT_LEN, Color.BLUE, Color.BLACK, Color.RED).hide();
		y += SPLASH_CONTROL_Y_STEP;

		ui.addScrollableList("splashColor", "Color", splashColorNames, 0, EFFECT_CONTROLS_X + 15, 30, 100, 100, 15, 15)
				.hide();
		y += SPLASH_CONTROL_Y_STEP;

		ui.addSlider("splashTailFade", "Tail Fade Rate", x, y, SPLASH_MIN_TAIL_FADE, SPLASH_MAX_TAIL_FADE,
				SPLASH_DAFAULT_TAIL_FADE).hide();
		y += SPLASH_CONTROL_Y_STEP;

		// addSlider("splashHeadFade", "Head Fade Rate", x, y,
		// SPLASH_MIN_HEAD_FADE, SPLASH_MAX_HEAD_FADE, SPLASH_DAFAULT_HEAD_FADE).hide();
		// y += SPLASH_CONTROL_Y_STEP;

		ui.addSlider("splashVelocityBrightnessImpact", "Velocity To Bright", x, y, SPLASH_MIN_VELO_BRI,
				SPLASH_MAX_VELO_BRI, SPLASH_DAFAULT_VELO_BRI).hide();
		y += SPLASH_CONTROL_Y_STEP;

		ui.addSlider("splashVelocitySpeedImpact", "Velocity To Speed", x, y, SPLASH_MIN_VELO_SPEED,
				SPLASH_MAX_VELO_SPEED, SPLASH_DAFAULT_VELO_SPEED).hide();
		y += SPLASH_CONTROL_Y_STEP;
	}

	public void addAnimationControls() {
		ui.addScrollableList("animationlist", "Animations", animationNames, 0, EFFECT_CONTROLS_X + 15, 30, 100, 100, 15,
				15).hide();
	}

	int[][] Keys = new int[88][2];
	int[][] Leds = new int[88][2];
	int rectASizeX = 0;
	int rectBSizeX = 0;
	int rectBX = 795;

	public void leftArrow() {
		if (counter <= 0) {
			numberselected = 176;
			firstNoteSelected = 21;
			lastNoteSelected = 108;
			return;
		}
		counter--; // increment counter each time button is pressed
		println("counter: " + counter);
		if (counter == 3) {
			rectASizeX = 135;
			rectBSizeX += 105;
			numberselected = 122;
			firstNoteSelected = 36;
			lastNoteSelected = 96;
			println("Selected number led: " + numberselected);
			println("Selected first note: " + firstNoteSelected);
			println("Selected last note: " + lastNoteSelected);
		}
		if (counter == 2) {
			rectASizeX -= 75;
			rectBSizeX += 30;
			numberselected = 146;
			firstNoteSelected = 28;
			lastNoteSelected = 100;
			println("Selected number led: " + numberselected);
			println("Selected first note: " + firstNoteSelected);
			println("Selected last note: " + lastNoteSelected);
		}
		if (counter == 1) {
			rectASizeX = 60;
			rectBSizeX += 30;
			numberselected = 152;
			firstNoteSelected = 28;
			lastNoteSelected = 103;
			println("Selected number led: " + numberselected);
			println("Selected first note: " + firstNoteSelected);
			println("Selected last note: " + lastNoteSelected);
		}
		if (counter == 0) {
			rectASizeX -= 60;
			rectBSizeX -= 60;
			numberselected = 176;
			firstNoteSelected = 21;
			lastNoteSelected = 108;
			println("Selected number led: " + numberselected);
			println("Selected first note: " + firstNoteSelected);
			println("Selected last note: " + lastNoteSelected);
		}
		if (counter == 0) {
			rectASizeX = 0;
			rectBSizeX = 0;
		}
	}

	public void rightArrow() {
		if (counter >= 4) {
			return;
		}
		counter++; // increment counter each time button is pressed
		println("counter: " + counter);
		if (counter == 0) {
			rectASizeX = 0;
			rectBSizeX = 0;
			numberselected = 176;
			firstNoteSelected = 21;
			lastNoteSelected = 108;
		}
		if (counter == 1) {
			rectASizeX += 60;
			rectBSizeX -= 45;
			numberselected = 152;
			firstNoteSelected = 28;
			lastNoteSelected = 103;
		}

		if (counter == 2) {
			rectASizeX = +60;
			rectBSizeX -= 30;
			numberselected = 146;
			firstNoteSelected = 28;
			lastNoteSelected = 100;
		}
		if (counter == 3) {
			rectASizeX = 135;
			rectBSizeX -= 30;
			numberselected = 122;
			firstNoteSelected = 36;
			lastNoteSelected = 96;
		}
		if (counter == 4) {
			rectASizeX = 135;
			rectBSizeX -= 105;
			numberselected = 98;
			firstNoteSelected = 36;
			lastNoteSelected = 84;
		}
		println("Selected number led: " + numberselected);
		println("Selected first note: " + firstNoteSelected);
		println("Selected last note: " + lastNoteSelected);
	}

	public void hideAllControls() {
		hideBGControls();
		hideDefaultControls();
		hideSplashControls();
		hideRandomControls();
		hideGradientControls();
		hideVelocityControls();
		hideSplitControls();
		hideAnimationControls();
		hidePianoRollControls();
		hidePianoRoll();
	}

	public void hidePianoRoll() {
		pianoRoll = null;
	}

//BG Controls
	public void showBGControls() {
		setControllersVisible(getBGControllers(), true);
	}

	public void hideBGControls() {
		setControllersVisible(getBGControllers(), false);
	}

//Default Controls
	public void showDefaultControls() {
		setControllersVisible(getDefaultControllers(), true);
	}

	public void hideDefaultControls() {
		setControllersVisible(getDefaultControllers(), false);
	}

//Splash Controls
	public void showSplashControls() {
		setControllersVisible(getSplashControllers(), true);
		ui.getController("modelist");
	}

	public void hideSplashControls() {
		setControllersVisible(getSplashControllers(), false);
	}

//Random Controls
	public void showRandomControls() {
		setControllersVisible(getRandomControllers(), true);
	}

	public void hideRandomControls() {
		setControllersVisible(getRandomControllers(), false);
	}

//Gradient Controls
	public void showGradientControls() {
		setControllersVisible(getGradinetControllers(), true);
	}

	public void hideGradientControls() {
		setControllersVisible(getGradinetControllers(), false);
	}

//Velocity Controls
	public void showVelocityControls() {
		setControllersVisible(getVelocityControllers(), true);
	}

	public void hideVelocityControls() {
		setControllersVisible(getVelocityControllers(), false);
	}

//Split Controls
	public void showSplitControls() {
		setControllersVisible(getSplitControllers(), true);
	}

	public void hideSplitControls() {
		setControllersVisible(getSplitControllers(), false);
	}

//Animation Controls
	public void showAnimationControls() {
		setControllersVisible(getAnimationControllers(), true);
	}

	public void hideAnimationControls() {
		setControllersVisible(getAnimationControllers(), false);
	}

//LearnMidi Controls
	public void showPianoRollControls() {
		setControllersVisible(getPianoRollControllers(), true);
	}

	public void hidePianoRollControls() {
		setControllersVisible(getPianoRollControllers(), false);
	}

	public void Color(int rgb) {
		Red = (int) red(rgb);
		Green = (int) green(rgb);
		Blue = (int) blue(rgb);
		ui.get(ScrollableList.class, "splashColor").setValue(splashColorNames.size() - 1);
		println("Colors: RED" + Red + ", GREEN" + Green + ", BLUE" + Blue);
	}

//BG List
	@SuppressWarnings("rawtypes")
	public List<Controller> getBGControllers() {
		List<Controller> cl = new ArrayList<>();
		cl.add(ui.getController("setBG"));

		return cl;
	}

//Default List
	@SuppressWarnings("rawtypes")
	public List<Controller> getDefaultControllers() {
		List<Controller> cl = new ArrayList<>();
		cl.add(ui.getController("Brightness"));
		cl.add(ui.getController("FadeOnVal"));
		cl.add(ui.getController("Color"));
		cl.add(ui.getController("colorlist"));

		return cl;
	}

//Splash List
	@SuppressWarnings("rawtypes")
	public List<Controller> getSplashControllers() {
		List<Controller> cl = new ArrayList<>();
		cl.add(ui.getController("splashMaxLength"));
		cl.add(ui.getController("FadeOnVal"));
		cl.add(ui.getController("Brightness"));
		cl.add(ui.getController("splashHeadFade"));
		cl.add(ui.getController("splashColor"));
		cl.add(ui.getController("Color"));

		// cl.add(ui.getController("splashVelocityBrightnessImpact"));
		// cl.add(ui.getController("splashVelocitySpeedImpact"));
		return cl;
	}

//Random List
	@SuppressWarnings("rawtypes")
	public List<Controller> getRandomControllers() {
		List<Controller> cl = new ArrayList<>();

		cl.add(ui.getController("Brightness"));
		cl.add(ui.getController("FadeOnVal"));
		return cl;
	}

//Gradient List
	@SuppressWarnings("rawtypes")
	public List<Controller> getGradinetControllers() {
		List<Controller> cl = new ArrayList<>();

		cl.add(ui.getController("Brightness"));
		cl.add(ui.getController("FadeOnVal"));
		cl.add(ui.getController("colorlist"));
		cl.add(ui.getController("Color"));
		cl.add(ui.getController("setLeftSideG"));
		cl.add(ui.getController("setMiddleSideG"));
		cl.add(ui.getController("setRightSideG"));

		return cl;
	}

//Velocity List
	@SuppressWarnings("rawtypes")
	public List<Controller> getVelocityControllers() {
		List<Controller> cl = new ArrayList<>();

		cl.add(ui.getController("Brightness"));
		cl.add(ui.getController("FadeOnVal"));

		return cl;
	}

//Split List
	@SuppressWarnings("rawtypes")
	public List<Controller> getSplitControllers() {
		List<Controller> cl = new ArrayList<>();

		cl.add(ui.getController("Brightness"));
		cl.add(ui.getController("FadeOnVal"));

		cl.add(ui.getController("colorlist"));
		cl.add(ui.getController("Color"));

		cl.add(ui.getController("setLeftSide"));
		cl.add(ui.getController("setRightSide"));
		return cl;
	}

//Animation List
	@SuppressWarnings("rawtypes")
	public List<Controller> getAnimationControllers() {
		List<Controller> cl = new ArrayList<>();

		cl.add(ui.getController("Brightness"));
		cl.add(ui.getController("animationlist"));

		return cl;
	}

//PianoRoll List
	@SuppressWarnings("rawtypes")
	public List<Controller> getPianoRollControllers() {
		List<Controller> cl = new ArrayList<>();

		cl.add(ui.getController("midiout"));
		cl.add(ui.getController("PianoRollLoadMidi"));
		cl.add(ui.getController("PianoRollRewind"));
		cl.add(ui.getController("PianoRollBackwardFragment"));
		cl.add(ui.getController("PianoRollPlayPause"));
		cl.add(ui.getController("PianoRollForwardFragment"));
		cl.add(ui.getController("PianoRollFollowKey"));

		ui.getController("midiout");
		return cl;
	}

	@SuppressWarnings("rawtypes")
	public void setControllersVisible(List<Controller> cl, boolean visible) {
		if (cl == null)
			return;
		for (Controller c : cl) {
			if (c != null) {
				c.setVisible(visible);
			}
		}
	}

	public void draw() {
		background(0);
		presetText = "Piano: ";
		if (firstNoteSelected == 21 && lastNoteSelected == 108) {
			presetText += "88 Keys";
		} else if (firstNoteSelected == 28 && lastNoteSelected == 103) {
			presetText += "76 Keys";
		} else if (firstNoteSelected == 28 && lastNoteSelected == 100) {
			presetText += "73 Keys";
		} else if (firstNoteSelected == 36 && lastNoteSelected == 96) {
			presetText += "61 Keys";
		} else if (firstNoteSelected == 36 && lastNoteSelected == 84) {
			presetText += "49 Keys";
		}

		// Piano type
		// PianoLED version tag uncomment when compiling to exe
		String VersionAppTag = "PianoLED: " + "v3.7";
		fill(255);
		text(presetText, 375, 15);
		text(VersionAppTag, 15, 150);

		// white keys
		// Initial x-coordinate of the first key
		int x = 0;
		for (int i = 0; i < whiteKeys.length; i++) {
			if (Keys[whiteKeys[i]][0] == 1) {
				fill(255, 0, 0);
			} else {
				fill(255);
			}
			// Draw the key at the current x-coordinate
			rect(x + 15, 64, 15, 70);
			fill(0);
			// Move the x-coordinate to the right by 10 pixels
			// to prepare for the next key
			x += 15;
		}
		// black keys
		for (int i = 0; i < blackKeys.length; i++) {
			if (Keys[blackKeys[i]][1] == 1) {
				fill(255, 0, 0);
			} else {
				fill(0);
			}
			// Use the x-coordinate from the list to draw each key
			rect(keyXCoordinates[i] + 15, 65, 8, 40);
		}
		// highlight piano size L&R boxes
		fill(0, 127);
		rect(15, 64, rectASizeX, 70);
		rect(rectBX, 64, rectBSizeX, 70);
		// block led strip with black color
		fill(0);
		rect(15, 54, rectASizeX, 10);
		rect(rectBX, 54, rectBSizeX, 10);

		if (pianoRoll != null) {
			pianoRoll.draw();
		}
	}

	int whiteKeyPitches[] = { 21, 23, 24, 26, 28, 29, 31, 33, 35, 36, 38, 40, 41, 43, 45, 47, 48, 50, 52, 53, 55, 57,
			59, 60, 62, 64, 65, 67, 69, 71, 72, 74, 76, 77, 79, 81, 83, 84, 86, 88, 89, 91, 93, 95, 96, 98, 100, 101,
			103, 105, 107, 108 };
// List of white keys in a 88-key piano
	int whiteKeys[] = { 0, 2, 3, 5, 7, 8, 10, 12, 14, 15, 17, 19, 20, 22, 24, 26, 27, 29, 31, 32, 34, 36, 38, 39, 41,
			43, 44, 46, 48, 50, 51, 53, 55, 56, 58, 60, 62, 63, 65, 67, 68, 70, 72, 74, 75, 77, 79, 80, 82, 84, 86,
			87 };
	int[] blackKeys = { 1, 4, 6, 9, 11, 13, 16, 18, 21, 23, 25, 28, 30, 33, 35, 37, 40, 42, 45, 47, 49, 52, 54, 57, 59,
			61, 64, 66, 69, 71, 73, 76, 78, 81, 83, 85 };
// Create a list of x-coordinates for each key
	int[] keyXCoordinates = { 11, 40, 56, 86, 101, 116, 145, 161, 191, 206, 221, 251, 266, 296, 311, 326, 356, 371, 401,
			416, 431, 461, 476, 506, 521, 536, 566, 581, 611, 626, 641, 671, 686, 715, 731, 746 };

}
